<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>Введение в R</title>
  <meta name="description" content="Введение в R">
  <meta name="author" content="R">
  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <!--[if lt IE 9]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>
<body>
  <script src="js/scripts.js"></script>
  <h1>Введение в R</h1>
   Это представление R ( "GNU S"), языка и среды для статистических вычислений и графики. R близка к популярной системе S, которая была разработана в Bell Laboratories Джоном Чамберсом и др.. Она предусматривает широкий спектр статистических и графических методов (линейное и нелинейное моделирование, статистические тесты, анализ временных рядов, классификация, кластеризация, ...).
  <p>
  	Это руководство содержит информацию о типах данных, программных<br>конструкциях, статистическом моделирования и визуализации данных.<br><br>Текущая версия этого документа - 2.6.0 (2007-10-03).<br><br>ISBN 3-900051-12-7<br><br>Предисловие<br><br>Это введение в R возникло из первоначального сборника заметок описывающих<br>среды S и S-Plus написанных Венаблес Билл и Дэвид М. Смит (Инсайтфул<br>корпорация). Мы внесли ряд небольших изменений, чтобы отразить различия<br>между R и S кодом, и расширить некоторые материалы.<br><br>Мы хотели бы выразить искреннюю благодарность Билл Венаблес (и Дэвид Смит)<br>за согласие на распространение этой модифицированной версии заметок на<br>таких условиях, а также сообществу R за сделанные замечания.<br><br>Замечания и исправления всегда приветствуются. Пожалуйста адресуйте<br>электронную почту на R-core@R-project.org.<br><br>Примечания для Читателя<br><br>Большинству R новичков следует начать с вводной сессии в Приложении<br>А. Это должно познакомить со стилем R сессий и, что более важно дать<br>некоторое впечатление о том, что действительно происходит.<br><br>Многие пользователи придут к R в основном из-за возможностей<br>визуализации. В этом случае можно приступать к чтению разделов описывающих<br>графические возможности практически в любое время и не ждать, пока будут<br>усвоены все предыдущие разделы.<br><br>1.1 R среда<br><br>R представляет собой набор программных средств для манипуляции данными,<br>вычислений и графического отображения. Среди прочего возможно<br><br>* эффективная обработка и хранение данных<br><br>* набор операторов для обработки массивов, в частности матриц,<br><br>* цельная, непротиворечивая, комплексная коллекция утилит для анализа<br>данных,<br><br>* графические средства для анализа данных и визуализации либо<br>непосредственно на компьютере или при выводе на печать, а также<br><br>* хорошо развитой, простой и эффективный язык программирования<br>(под названием "S"), который включает условий, циклы, определенные<br>пользователем рекурсивные функции и возможности ввода вывода.<br>(Действительно большинство поддерживаемых системой функций сами написаны<br>на S языке.)<br><br>Термин "окружение"/"среда" введен что бы подчеркнуть наличие полностью<br>спланированной и непротиворечивой системы, а не постепенно возникшего<br>конгломерата весьма специфических и негибких утилит, как это часто бывает<br>с другим программным обеспечением анализа данных.<br><br>R выступает как средство разработки новых методов интерактивного анализа<br>данных. Он быстро разрабатывается, и был оброс большой коллекцией<br>пакетов. Однако, большинство программ, пишущихся на R принципиально<br>являются программами-однодневками, написанные для конкретного случая<br>анализа данных.<br><br>1.2 Сопутствующее программное обеспечение и дополнительная документация<br><br>R можно рассматривать как реализацию языка S, который был разработан<br>в Bell Laboratories Риком Бекером, Джоном Чамбером и Алланом Вилксом,<br>и который собственно лежит в основе S-Plus систем.<br><br>Эволюция S языке характеризуется в четырех книгах Джона Чамбера с<br>соавторами. Для R, основой является "Новый S Язык: Программная среда<br>для анализа данных и визуализации" Ричарда А. Беккера, Джон М. Чамбера и<br>Аллана Р. Вилкса. Новые возможности реализации S в 1991 году освещаются<br>в "Статистические модели в S" под редакцией Джон М. Чамбера и Тревора<br>Дж. Хастие. Формальные методы и классы из пакета методов основаны на<br>описаниях в "Кодирование с данными" Джона М. Чамбера. См. раздел Ссылки<br>для точных обращений к источникам.<br><br>Сейчас есть целый ряд книг, которые описывают, как использовать R для<br>анализа данных и статистических вычислений, также документация S / S-Plus,<br>как правило, может быть использована с R, если помнить о различиях между<br>реализациями S. См. "Какая существует документация по R"? .<br><br>1.3 R и статистика<br><br>В нашем описании R среды не упоминается о статистике, но многие люди<br>используют R в качестве статистической системы. Мы предпочитаем думать<br>о нем как о окружении, в котором были реализованы многие классические и<br>современные статистические методы. Некоторые из них встроены в базовое<br>окружение R, но многие из них поставляется как пакеты. Есть около 25<br>пакетов поставляемых с R (так называемые "стандарт" и "рекомендовано"<br>наборы пакетов), много больше можно получить через CRAN семейство интернет<br>сайтов (через http://CRAN.R-project.org) и из других источников. Более<br>подробную информацию о пакетах рассмотрим позднее (см. Пакеты).<br><br>Большинство классических статистик и многое из последних методик доступно<br>для использования в R, но пользователи должны быть готовы к небольшим<br>усилиям, чтобы найти нужное.<br><br>Существует важное различие между философией в S (и, следовательно, R)<br>и других основных статистических системах. В S статистический анализ,<br>как правило, выполняется в виде серии шагов, с сохранением промежуточных<br>результатов в объектах. Так когда SAS и SPSS выведут обильные результаты<br>процедуры регрессионного или дискриминантного анализа, R выведет минимум<br>результатов и сохранит вывод в подогнанный объект для последующего<br>использования в дальнейшем в вызываемых R функциях.<br><br>1.4 R и графический десктоп<br><br>Самый удобный способ пользоваться R это использовать графическую<br>рабочую станцию с оконным менеджером. Это руководство адаптировано к<br>пользователям которые обладают такой возможностью. В частности мы будем<br>изредка ссылаться на использование R в среде X widows, хотя значительная<br>часть того, что говорится обычно применимо к любой реализации R среды.<br><br>Большинство пользователей сталкиваются время от времени с необходимостью<br>взаимодействовать непосредственно с операционной системы на своем<br>компьютере. В этом руководстве, мы в основном обсуждаем взаимодействие<br>с операционной системой UNIX машин. Если вы запускаете R под Windows<br>или MacOS нужно будет сделать несколько небольших корректировок.<br><br>Настройка рабочей станции для использования в полной мере возможностей<br>настройки R является простой, но несколько утомительной процедурой, и<br>не будет подробно рассматриваться здесь. Пользователи в затруднительной<br>ситуации должны стремиться получить помощь доступного им специалиста.<br><br>1.5 Используем R интерактивно<br><br>Когда Вы используете R программу, она выводит приглашение в момент<br>ожидания ввода команд. По умолчанию приглашение это "&gt;", что в UNIX<br>может совпадать с приглашением оболочки, и поэтому может показаться,<br>что ничего не произошло. Однако, как мы увидим, можно, при желании,<br>легко выбрать другое R приглашение. В дальнейшем мы предполагаем, что<br>приглашение оболочки UNIX является "$".<br><br>При использовании R в UNIX рекомендуется начать со следующего:<br><br>1. Создать отдельный подкаталог, например work, для файлов данных,<br>которые Вы будете обрабатывать в R. Это будет рабочий каталог, в случаях<br>когда вы используете R для этой конкретной задачи.<br><br>$ mkdir work $ cd work<br><br><br>2. Запустить R программу с помощью команды<br><br>$ R<br><br><br>3. С этого момента можно вводить R команды (см. ниже). 4. Выходом из R<br>программы служит команда<br><br>&gt; q()<br><br><br>На этом этапе Вас спросят нужно ли Вам сохранить данные из вашей R<br>сессии. На некоторых системах это будет сделано при помощи диалогового<br>окна, а на других вы получите текстовое приглашение, на которые можно<br>ответить "да", "нет" или "отмена" (достаточно будет ввести первую букву)<br>для того что бы сохранить данные и закрыть сессию, закрыть без сохранения<br>или вернуться в R сессию. Данные, которые будут сохранены будут доступны<br>в последующих R сессиях.<br><br>Последующие R сессии требуют меньше действий.<br><br>1. Сделать work рабочим каталогом и запустить программу, как делали ранее:<br><br>$ cd work $ R<br><br><br>2. Использовать R программу, которую завершить при помощи q() команды<br>в конце сессии.<br><br>Для использования под Windows R процедура в основе своей та же.<br>Создайте папку как рабочий каталог, и установите ее в поле Start Вашего<br>R ярлыка. Затем запустите R двойным нажатием на иконку.<br><br>1.6 Первый сеанс<br><br>Читателям, желающим испытать R на компьютере, прежде чем приступить<br>настоятельно рекомендуется проработать вводную сессию приведенную в<br>сессии примера А.<br><br>1.7 Получение помощи по функциям и возможностям<br><br>R имеет встроенную команду help по аналогии с командой man в UNIX.<br>Чтобы получить дополнительную информацию о какой-либо конкретной функции,<br>например solve, нужно ввести<br><br>&gt; help(solve)<br><br>Альтернативный вариант<br><br>&gt;?solve<br><br>Для наименования обозначенного специальными символами, аргумент должен<br>быть помещен в двойные или одиночные кавычки, что превращает его в<br>"строку символов": Это также необходимо для некоторых слов имеющих<br>синтаксическое значение, включая if, for и функции.<br><br>&gt; help("[[")<br><br>Любая форма кавычек может быть использована, чтобы экранировать другие<br>кавычки, как в строке "It's important". Мы будем придерживаться по<br>возможности использования двойных кавычек.<br><br>На большинстве установленных R систем справка доступна в формате HTML,<br>достаточно выполнить<br><br>&gt; help.start()<br><br>будет запущен веб-браузер, что позволит просматривать страницы помощи в<br>режиме гипертекста. В UNIX, последующие help запросы будут направляться в<br>HTML вариант системы помощи. Ссылка `Поисковая система и ключевые слова"<br>доступная на странице загружаемой после выполнения help.start () является<br>особенно полезной, поскольку содержит высокоуровневое оглавление, для<br>поиска доступных функций. Это может быть очень удобно, чтобы быстро<br>получить понимание вопроса, и понять широкий спектр возможностей<br>предлагаемых R.<br><br>help.search команда позволяет искать подсказку различными способами:<br>выполните ?help.search для подробностей и конкретных примеров.<br><br>Примеры по теме страницы помощи можно, как правило, запустить коммандой<br><br>&gt; example(тема)<br><br>Windows версии R имеют другие дополнительные системы помощи:<br>воспользуйтесь<br><br>&gt;?help<br><br>для дальнейших подробностей.<br><br>1.8 Команды R, учет регистра и т.п.<br><br>Технически R является языком выражений с очень простым синтаксисом.<br>Он учитывает регистр как и большинство других программ UNIX, так<br>"А" и "а" различные символы и будут обозначать различные переменные.<br>Набор символов, которые могут быть использованы как имена в R зависит<br>от операционной системы и страны, в которых будет запущен R (технически<br>говоря, от используемой локали). Обычно разрешены все алфавитно-цифровые<br>символы сноска1 (а в некоторых странах включая и акцентированные буквы)<br>вместе с "." и "_", с ограничением, что имя должно начинаться с "." или<br>буквы, а если оно начинается с "." второй символ не должен быть цифрой.<br><br>Простые команды состоят из выражений либо присвоений. Если выражение<br>вводится как команда, оно вычисляется, выводится (если специально не<br>сделано невидимым), и результат теряется. Присвоение также вычисляет<br>выражение и передает значение переменной, но результат автоматически<br>не выводится.<br><br>Команды разделяются либо точкой с запятой (";"), или переводом<br>строки. Простые команды могут быть сгруппированы в единое составное<br>выражение фигурными скобками ( "{" и "}"). Комментарии могут быть<br>практически сноска2 где угодно, начинаются с символа решетки ("#"),<br>при этом все до конца строки является комментарием.<br><br>Если команда не завершена в конце строки, R выдаст особое приглашение,<br>по умолчанию<br><br>+<br><br>во второй и последующих строках и продолжит ожидать ввода пока команда<br>не будет синтаксически завершена. Это приглашение может быть изменено<br>пользователем. Мы будем как правило опускать приглашение продолжения<br>ввода и обозначать продолжение простым отступом.<br><br>Командные строки набираемые в консоли являются ограниченными сноска3 в<br>размере до 1024 байт (не символов!).<br><br>1.9 Повтор и коррекция предыдущих команд<br><br>Во многих версий UNIX и Windows, R предусматривает механизм восстановления<br>и повторного выполнения предыдущей команды. Вертикальные стрелки на<br>клавиатуре можно использовать для прокрутки вперед и назад по истории<br>команд. Когда команда найдена таким способом, курсор может перемещаться<br>внутри команды с помощью горизонтальных стрелок, можно удалять символы<br>при помощи клавиши &lt;DEL&gt; или добавлять при помощи остальных клавиш. Более<br>подробная информация предусмотрена далее: см. Редактор командной строки.<br><br>Возможности повтора и редактирования в UNIX являются гибко<br>настраиваемыми. Вы можете узнать, как это сделать, прочитав часть<br>руководства о библиотеке readline.<br><br>Кроме того, текстовый редактор Emacs предоставляет более полные механизмы<br>поддержки (посредством ESS, Emacs Speaks Statistics) для работы в<br>интерактивном режиме с R. См. R и Emacs.<br><br>1.10 Выполнение команд записанных в файл или перенаправление вывода в файл<br><br>Если команды сноска4 хранятся во внешнем файле, например commands.R<br>в рабочем каталоге work, они могут быть выполнены в любой момент в R<br>сессии с помощью команды<br><br>&gt; source("commands.R")<br><br>Для Windows Source можно найти в меню "Файл". Функция sink,<br><br>&gt; sink("record.lis")<br><br>будет направлять весь последующий вывод консоли во внешний файл,<br>record.lis. Команда<br><br>&gt; sink()<br><br>восстанавливает вывод в консоли еще раз.<br><br>1.11 Сохранение данных и удаление объектов<br><br>Записи которые R создает и которыми манипулирует известны как объекты. Это<br>могут быть переменные, массивы чисел, строки символов, функции, или<br>более сложные структуры построены из этих компонентов.<br><br>В ходе сессии R создаются и хранятся поименованные объекты (мы обсудим<br>этот процесс на следующей сессии). R команда<br><br>&gt; objects()<br><br>(также как ls()) может быть использована для отображения названий (в<br>основном) объектов, которые в настоящее время хранятся в R. Набор объектов<br>который в настоящее время хранится называется рабочее пространство. Чтобы<br>удалить объекты доступна функция rm:<br><br>&gt; rm(x, y, z, ink, junk, temp, foo, bar)<br><br>Все объекты, созданные в ходе R сессий могут быть сохранены в файл<br>для использования в последующих R сессиях. В конце каждой сессии R Вам<br>предоставляется возможность сохранить все имеющиеся в настоящее время<br>объекты. Если Вы подтвердите, что вы хотите этого, объекты записываются<br>в файл .RData сноска5 в текущем каталоге, а строки команд, использованных<br>в сессии сохраняются в файл .Rhistory.<br><br>Если R будет запущена позже из этого каталога рабочее пространство<br>будет перезагружено из этого файла. Одновременно загрузится связанная<br>история команд.<br><br>Мы рекомендуем Вам использовать отдельную рабочую директорию для каждого<br>из анализов проведенных в R. Очень распространено использовать для<br>объектов созданых в ходе анализа имена х и у. Имена, подобные этим имеют<br>смысл в контексте конкретного анализа, но может быть довольно трудно<br>определить, что они означают, когда несколько анализов были проведены<br>в одном и том же каталоге.<br><br>2.1 Вектора и присваивания<br><br>R оперирует именованными структурами данных. Простейшая такая структура<br>это численный вектор, который представляет собой совокупность, состоящую<br>из упорядоченного набора чисел. Чтобы создать вектор с именем х, например<br>состоящий из пяти чисел, а именно 10.4, 5.6, 3.1, 6.4 и 21.7, используют<br>такую команду R<br><br>&gt; х &lt;- с(10.4, 5.6, 3.1, 6.4, 21.7)<br><br>Это выражение присваивания, использует функцию с(), которая в этом<br>контексте может содержать произвольное число аргументов векторов и<br>значение которой есть вектор полученный путем объединения аргументов<br>край в край. сноска6<br><br>Одиночное число входящее в выражение трактуется как вектор единичной<br>длины.<br><br>Учтите, что оператор присваивания ("&lt;-"), который состоит из<br>двух символов "&lt;" ( "меньше") и "-" ( "минус") выполняется строго<br>однонаправлено и "указывает" на объект получающий значение выражения.<br>В большинстве случаев в качестве альтернативы может быть использован<br>оператор "=". Присваивание можно также сделать с помощью функции<br>assign(). Эквивалентный способ присвоения, приведенному выше, выглядит:<br><br>&gt; assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))<br><br>Обычно оператор, &lt;-, можно рассматривать как синтаксическое сокращение<br>приведенного.<br><br>Присваивание можно также делать в обратном направлении, используя<br>очевидные изменения в оператора присваивания. Так тоже самое присваивание<br>можно сделать используя<br><br>&gt; с(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; х<br><br>Если выражение используется как законченная команда, его значение<br>выводится и теряется сноска7. Так, если мы теперь введем команду<br><br>&gt; 1/х<br><br>то частное пяти элементов будет выведено на терминал (и значение х,<br>разумеется, не изменится).<br><br>Дальнейшее присваивание<br><br>&gt; y &lt;- c(x, 0, x)<br><br>создаст вектор y с 11 элементами, состоящий из двух копий х с нулем<br>между ними.<br><br>2.2 Действия над векторами<br><br>Вектора могут быть использованы в арифметических выражениях, и в этом<br>случае операции выполняются элемент за элементом. Вектора, включающиеся<br>в одно и то же выражение, не обязательно должны быть одной длины. Если<br>длины отличаются, результат выражения это вектор с такой же длиной, как<br>самый длинный вектор, который встречается в выражении. Короткие векторы<br>в выражении используются повторно столько раз, сколько это необходимо<br>(возможно не целое число раз), до тех пор, пока они не совпадут с<br>длинной самого длинного вектора. В частности константа будет просто<br>повторяться. Так, учитывая предыдущие присваивания, команда<br><br>&gt; v &lt;- 2*х + у + 1<br><br>создает новый вектор v длинной 11 составленный путем сложения, элемент<br>с элементом, 2*х повторенного 2,2 раза, y повторенного только раз,<br>и 1 повторенной 11 раз.<br><br>Элементарные арифметические операторы это +, -, *, / и ^ для возведения<br>в степень. Дополнительно присутсвуют все простые арифметические<br>функции. log, exp, sin, cos, tan, sqrt, и т.д., все имеют обычное<br>значение. max и min выделяют соответственно наибольший и наименьший<br>из элементов вектора. range это функция, значение которой вектор из<br>двух элеменов, а именно c(min(x), max(x)). length(x) - количество<br>элементов в х, sum(x) дает сумму значений элементов в х, а prod(x) их<br>произведение. Две статистические функции это mean(x), которая вычисляет<br>выборочное среднее, что соответсвует sum(x)/length(x), и var(х),<br>которая дает<br><br>sum((x-mean(x))^2)/(length(x)-1)<br><br>или выборочную дисперсию. Если аргумент var() - это n-на-р матрица,<br>значение - р-на-р матрица выборочной ковариации, полученная путем<br>интерпретации строк как p независимых векторов-выборок.<br><br>sort(x) возвращает вектор того же размера как х с элементами расположеными<br>в порядке возрастания; однако есть и другие более гибкие возможности<br>сортировки (см. order() или sort.list(), которые для сортировки<br>производят перестановки). Заметим, что max и min выделяют наибольшей и<br>наименьшей значение в своих аргументах, даже если они получат несколько<br>векторов. Параллельные максимальные и минимальные функции pmax и pmin<br>возвращают вектор (длиной, равной длине длиннейшего аргумента), который<br>содержит в каждом своем элементе наибольшее (наименьшее) значение на<br>этой позиции во всех входных векторах. В большинстве случаев пользователю<br>не важно, являются ли "числа" в числовых векторах целыми, реальными или<br>даже комплексными. Внутренние расчеты осуществляются в реальных числах<br>двойной точности, или комплексных числах двойной точности, если входные<br>данные являются комплексными.<br><br>Для работы с комплексными числами, надо явно обеспечить мнимую<br>часть. Таким образом<br><br>sqrt(-17)<br><br>даст NaN и предупреждение, но<br><br>sqrt(-17+0i)<br><br>будет обработано, как комплексное число.<br><br>2,3 Генерация регулярных последовательностей<br><br>R имеет ряд возможностей для получения общеупотребительных<br>последовательностей чисел. Например 1:30 - вектор с(1, 2, ..., 29,<br>30). Оператор двоеточие имеет высший приоритет в выражении, так, например<br>2*1:15 это вектор с(2, 4, ..., 28, 30). Присвойте n &lt;- 10 и сравните<br>последовательности 1:n-1 и 1:(n-1).<br><br>Выражение 30:1 может быть использовано для создания обратной<br>последовательности.<br><br>Функция seq() представляет более общий механизм для генерации<br>последовательностей. Она имеет пять аргументов, лишь часть из которых<br>может быть определена одновременно. Первые два аргумента, если они заданы,<br>определяют начало и конец последовательности, и если указаны только два<br>аргумента возвращаемый результат такой же, как у оператора двоеточие. Так<br>seq(2,10) - это тот же вектор, как и 2:10.<br><br>Параметры seq(), а также для многих других функций R, также можно<br>задавать по имени, тогда порядок, в котором они появляются, не имеет<br>значения. Первые два параметра могут быть обозначены from=значение и<br>to=значение; таким образом, seq(1,30), seq(from=1, to=30) и seq(to=30,<br>from=1), тоже самое что и 1:30. Следующие два параметра seq(), можно<br>присвоить как by=значение и length=значение, что определяет размер шага<br>и длину последовательности соответственно. Если ни один из них не задан,<br>применяется заданное по by=1.<br><br>Например<br><br>&gt; seq(-5, 5, by=.2) -&gt; s3<br><br>генерирует в s3 вектор c(-5.0, -4.8, -4.6, ..., 4.6, 4.8, 5.0).<br>Точно так же<br><br>&gt; s4 &lt;- seq(length=51, from=-5, by=.2)<br><br>порождает тот же вектор в s4.<br><br>Пятый параметр можно задать как along=вектор, когда он задан другие<br>параметры недопустимы, и он создает последовательность 1, 2, ...,<br>length(вектор), или пустую последовательность, если вектор пуст (как<br>может случится).<br><br>Дополнительно можно использовать функцию rep(), которая может повторять<br>объект различными сложными способами. Простейшей формой является<br><br>&gt; s5 &lt;- rep(x, times=5)<br><br>, что поместит в s5 пять копий х край-в-край. Другой полезный вариант<br><br>&gt; s6 &lt;- rep(x, each=5)<br><br>, что копирует каждый элемент х пять раз, прежде чем переходит к<br>следующему элементу.<br><br>2.4 Логические векторы<br><br>Также как числовыми векторами, R может манипулировать логическими<br>значениями. Элементы логического вектора могут иметь значения TRUE,<br>FALSE и NA (для "пропущено", см. ниже). Первые два часто сокращают<br>до T и F, соответственно. Заметьте, однако, что T и F всего лишь<br>переменные, которые установлены в TRUE и FALSE по умолчанию, но<br>не зарезервированные идентификаторы и, следовательно, могут быть<br>переназначены пользователем. Поэтому вы всегда должны использовать TRUE<br>и FALSE. Логические векторы порождаются сравнениями. Например<br><br>&gt; temp &lt;- x &gt; 13<br><br>задает temp как вектор той же длины, как х со значениями FALSE<br>соответствующими элементам х, когда условие не выполняется, и TRUE,<br>когда имеет место.<br><br>Логические операторы &lt;, &lt;=, &gt;, &gt;=, == для точного равенства и !=<br>для неэквивалентности. Кроме того, если c1 и c2 являются логическими<br>выражениями, тогда c1 &amp; c2 является их умножением ("и"), c1 | c2 их<br>сложением ("или") и !c1 является отрицанием c1. Логические векторы могут<br>быть использованы в обычных арифметических операциях, и в этом случае они<br>приводятся к числовым векторам, FALSE становится 0, а TRUE становится<br>1. Однако есть ситуации, когда логические векторы и их приведения к<br>численному виду отличаются, для примера см. следующий подраздел.<br><br>2.5 Пропушенные значения<br><br>В некоторых случаях компоненты вектора могут быть не полностью<br>известны. Когда элемент или значение "отсутствует" или имеют "пропушенное<br>значение" в статистическом смысле, внутри вектора для него может быть<br>зарезервировано место, присвоением ему особого значения NA. В целом<br>любая операция с NA имеет результатом NA. Причина этого правила проста,<br>если операции определена неполностью, результат не может быть известен и,<br>следовательно, отсутствует.<br><br>Функция is.na(х) дает логический вектор того же размера, как x со<br>значением TRUE там и только там, где соответствующий элемент х является<br>NA.<br><br>&gt; z &lt;- c(1:3,NA); ind &lt;- is.na(z)<br><br>Учтите, что логическое выражения х == NA немного отличается от is.na(х),<br>поскольку NA на самом деле не значение, а признак отсутствующей<br>величины. Так х == NA это вектор той же длины что и х, все значения<br>которого будут NA, так как само логическое выражение является неполным и,<br>следовательно, неразрешимым.<br><br>Заметим, что существует второй тип "пропущенных" значений, которые<br>возникают в численных вычислениях, так называемое значение не-число,<br>NaN. Примерами являются<br><br>&gt; 0/0<br><br>или<br><br>&gt; Inf - Inf<br><br>, которые оба дают NaN поскольку результат не может быть определен<br>по правилам.<br><br>В целом, is.na(хх) дает TRUE как для NA и значения NaN. Что бы отличить<br>их, is.nan(хх) дает TRUE только для NaNs. Отсутствующие значения иногда<br>выводятся как &lt;NA&gt;, тогда когда как символьные вектора будут выводится<br>без квотирования.<br><br>2.6 Символьные вектора<br><br>Символьные величины и символьные вектора часто используются в R, например,<br>как метки графиков. При необходимости они описываются последовательностю<br>символов, ограниченных двойными кавычками, например, "x-values", "New<br>iteration results".<br><br>строки символов вводятся с использованием либо двойные (") или одиночные<br>(') кавычки, но печатаются с использованием двойных кавычек (или иногда<br>без кавычек). При этом используются управляющие последовательности в<br>стиле C, с использованием \ как esc-символ, так \\ вводится и выводится<br>как \\, а внутри двойных кавычек "вводится как \". Другие полезные<br>являются управляющие последовательности \n, новая строка, \t, табуляция<br>и \b, забой.<br><br>Символьные вектора можно объединять в вектор с помощью функции с();<br>случаи такого использования будут встречатся часто. Функция paste()<br>принимает произвольное количество аргументов и объединяет их по очереди в<br>одну строку символов. Все числа включенные в аргументы очевидным образом<br>преобразуются в символьные строки, так же, как если бы они были выведены<br>на печать. Аргументы по умолчанию разделены в результате одним пробелом,<br>но это может быть изменено именованым параметром, sep="строка", который<br>заменяет разделитель на "строка", возможно нулевой длины.<br><br>Например<br><br>&gt; labs &lt;- paste(c("X","Y"), 1:10, sep="")<br><br>преобразует labs в символьный вектор<br><br>c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")<br><br>Обратите внимание что имеет место повторное использование коротких<br>списков; так с("X", "Y") повторяется 5 раз что бы совпасть с<br>последовательностью 1:10. сноска8<br><br>2.7 Индексные вектора; выбор и изменение подмножества набора данных<br><br>Подмножество элементов вектора может быть выбрано добавлением к имени<br>вектора индексного вектора в квадратных скобках. В целом у любого<br>выражения, которое вычисляется в виде вектора, может аналогично быть<br>выбрано, путем добавления индексного вектора в квадратных скобках сразу<br>после выражения, подмножество его элементов.<br><br>Такой индексный вектор может иметь любой из четырех различных типов.<br><br>1. Логический вектор. В этом случае индексный вектор должен быть<br>той же длины, как и вектор из которого которые должны быть выбраны<br>элементы. Значения соответствущие TRUE в индексном векторе выбираются,<br>а соответствующие FALSE пропускаются. Например<br><br>&gt; y &lt;- x[!is.na(x)]<br><br>создает (или пересоздает) объект y в котором будут содержаться, "не<br>отсутствующие" значения х, с сохранением порядка. Заметим, что если х<br>имеет отсутствующие значения, y будет короче, чем х. Итак<br><br>&gt; (x+1)[(!is.na(x)) &amp; x&gt;0] -&gt; z<br><br>создает объект z и помещает в него значения вектора х+1, для которых<br>соответствующие значения в х было одновременно не отсутсвующим и<br>положительным. 2. Вектор положительных целых величин. В этом случае<br>значения в индексном векторе должны попадать в набор {1, 2, ...,<br>length(х)}. В результат выбираются и объединяются, в указанном порядке,<br>соответствующие элементы вектора. Индексный вектор может быть любой длины,<br>а результат имеет такую же длину как индексный вектор. Например х[6]<br>является шестым элементом х и<br><br>&gt; х[1:10]<br><br>выбирает первые 10 элементов х (предполагая, что length(x) не менее<br>10). Итак<br><br>&gt; c("x","y")[rep(c(1,2,2,1), times=4)]<br><br>(безусловно маловероятно чтобы так пришлось делать) выводит символьный<br>вектор длиной 16, содержащий "х", "у", "у", "х" повторенные четыре<br>раза. 3. Вектор отрицательных целых величин. Такой индексный вектор<br>определяет значения которые должны быть исключены, а не включены.<br>Таким образом<br><br>&gt; y &lt;- x[-(1:5)]<br><br>передает в у все, кроме первых пяти элементов х. 4. Вектор символьных<br>строк. Эта возможность применяется только тогда, когда объект имеет<br>такое свойство как имена для обращения к его компонентам. В этом случае<br>под-вектор вектора имен может быть использован так же, как положительные<br>целые метки в пункте 2 выше.<br><br>&gt; fruit &lt;- c(5, 10, 1, 20) &gt; names(fruit) &lt;- c("orange", "banana",<br>"apple", "peach") &gt; lunch &lt;- fruit[c("apple","orange")]<br><br>Преимуществом является то, что буквенно-цифровые имена зачастую проще<br>запомнить, чем числовые индексы. Эта возможность, как мы увидим позже,<br>особенно применима в сочетании с фреймами данных.<br><br>Индексированное выражение также может помещаться на принимающей стороне<br>присваивания, в этом случае присваивание осуществляется только на<br>проиндексированные элементы вектора. Выражение должно быть в форме<br>вектор[индекс_вектор], так как произвольное выражение вместо имени<br>вектора не имеют здесь смысла.<br><br>Получающий значение вектор должен подходить к длине индексного вектора,<br>а в случае логического индексного вектора он должен быть именно той же<br>длины, как вектор которым индексируют.<br><br>Например<br><br>&gt; x[ is.na(x)] &lt;- 0<br><br>заменяет все отсутствующие значения в х нулями, а<br><br>&gt; y[y &lt; 0] &lt;- -y[y &lt; 0]<br><br>действует так же, как<br><br>&gt; y &lt;- abs(y)<br><br>2.8 Другие типы объектов<br><br>Вектора являются наиболее важными типами объектов в R, но есть и некоторые<br>другие, которые мы будем обсуждать более строго в дальнейших разделах.<br><br>* матрицы или в целом массивы как многомерное обобщение векторов.<br>Фактически они являются векторами, которые могут быть проиндексированы<br>двумя или более индексами, и должны выводится в специальном формате.<br>См. Массивы и матрицы.<br><br>* факторы представляют компактный способ работы с качественными<br>данными. См. Факторы.<br><br>* списки это обобщенная форма векторов, в которой различные элементы не<br>обязаны быть одного типа, и зачастую сами элементы являются векторами<br>или списками. Списки предоставляют удобный способ возвращения результатов<br>статистических вычислений. См. Списки.<br><br>* таблицы данных это матрице-подобные структуры, в которой столбцы<br>могут быть различных типов. Думайте о фреймах данных как о "матрицах<br>данных" с одной строкой на каждое наблюдение, но включающих (возможно)<br>как числовые переменные, так и качественные. Многие эксперименты лучше<br>всего записываются во фреймах данных: воздействие качественное, а отклик<br>колличественный. См. Таблицы данных.<br><br>* функции сами также объекты R, которые можно сохранить в окружении памяти<br>рабочего проекта. Это обеспечивает простой и удобный способ расширения<br>R. См. Написание собственных функций.<br><br><br>3.1 Обязательные атрибуты: режим и продолжительность<br><br>R оперирует записями с технической точки известными как объекты.<br>Примерами могут быть векторы с численными (реальными) или комплексными<br>величинами, векторы с логическими значениями и векторы строк символов.<br>Они известны как структуры "атомы", поскольку их компоненты все<br>имеют одинаковый тип, или вид, а именно численным (numeric) сноска 9,<br>комплексным (complex), логическим (logical), символьным (character)<br>и прямого доступа (raw).<br><br>Все значения вектора должны иметь один и тот же тип. Таким образом,<br>любой вектор должен быть однозначно либо логическим, либо числовым,<br>либо комплексным, либо символьным или прямого доступа. (Единственным<br>допустимым исключением из этого правила является специальное "значение"<br>обозначаемое как NA для отсутствующих значений, хотя в реальности<br>различают несколько видов NA). Заметим, что вектор может быть пустым,<br>и все еще иметь тип. Например пустой вектор символьных строк обозначается<br>как character(0) а пустой численный вектор, как numeric(0).<br><br>R также работает с объектами, называемыми списки, которые имеют тип<br>list. Они являются упорядоченными последовательностями объектов, каждый<br>из которых может иметь любой тип. Списки известны как "рекурсивные", а не<br>"атомные" структуры, поскольку их компоненты могут сами быть списками<br>в своем собственном формате.<br><br>Другие рекурсивные структуры имеют типы функция (function) и выражение<br>(expression). Функции являются объектами, которые являются составной<br>частью системы R, наряду с аналогичными написанными самим пользователем<br>функциями, что мы обсудим детально позже. Выражения, как объекты<br>составляют самую сложную часть R, которая не будет обсуждаться в этом<br>руководстве, кроме как косвенно, когда мы будем обсуждать формулы,<br>используемые при моделировании в R.<br><br>Под типом объекта, мы имеем в виду базовый тип его основных<br>составляющих. Это особый случай "свойств" объекта. Другим свойством<br>каждого объекта является его длина. Функции mode(object) и length(object)<br>могут использоваться для определения типа и длины любых определенных<br>структур сноска10.<br><br>Другие свойства объекта обычно получают посредством attributes(object),<br>см. Получение и настройки свойств. Из-за этого, тип и длинну также<br>называют "внутренними характеристиками" объекта. Например, если z -<br>это комплексный вектор длины 100, тогда при операции mode(z) выводится<br>символьная строка "complex", а при length(z) выводится 100.<br><br>R заботится об изменении типа практически в любом месте, где это имеет<br>смысл, (и мало, где - нет). Например имея<br><br>&gt; z &lt;- 0:9<br><br>мы можем ввести<br><br>&gt; digits &lt;- as.character(z)<br><br>после чего digits содержит символьный вектор с("0", "1", "2", ...,<br>"9"). Далее приведение, или смена типа, реконструирует числовой вектора<br>снова:<br><br>&gt; d &lt;- as.integer (digits)<br><br>Теперь d и z являются идентичными. сноска11 Существует большой набор<br>функций вида as.нечто(), как для приведения от одного типа к другому<br>так для придания объекту ряда новых свойств которыми он пока не<br>обладает. Читателю придется проконсультироваться с несколькими файлами<br>руководства, чтобы освоится с этим.<br><br>3,2 Изменение длины объекта<br><br>"Пустой" объект все еще будет иметь тип. Например<br><br>&gt; e &lt;- numeric()<br><br>создает в е пустую структуру вектора численного типа. Аналогично<br>character() - это пустой символьный вектор, и так далее. Когда создан<br>объект любого размера, новые компоненты могут добавляться просто, придавая<br>значению его индекса значение за пределом текущего диапазона. Таким<br>образом<br><br>&gt; е[3] &lt;- 17<br><br>создает е как вектор длиной 3, (первые две компоненты, на данный момент,<br>обе NA). Это применимо к абсолютно любой структуре, при условии что тип<br>дополнительного компонента(ов) подходит типу объекта впереди.<br><br>Эта автоматическая регулировка длины объекта используется часто, например,<br>в функции ввода scan() . (см. Функция scan().)<br><br>Что бы наоборот, усечь размер объекта, потребуется сделать всего лишь<br>присваивание. Поэтому, если alpha объект длиной 10, тогда<br><br>&gt; alpha &lt;- alpha[2 * 1:5]<br><br>делает его объектом длиной 5 состоящим только из бывших компонент с четным<br>индексом. (Старые значения индекса при этом конечно не сохраняются.) Также<br>можно сохранить только первые три значения,<br><br>&gt; length(alpha) &lt;- 3<br><br>или вектор может быть расширен тем же способом ( отсутствующими<br>значениями).<br><br>3.3 Определение и установка свойств<br><br>Функция attributes(объект) возвращает список всех, не внутренних свойств,<br>в настоящее время определенных для данного объекта. Функция attr(объект,<br>имя) можно использовать для выбора конкретного свойства. Эти функции<br>используются редко, за исключением некоторых особых обстоятельств,<br>когда некоторые новые атрибуты создаются для некоторых конкретных целей,<br>например, что бы привязать дату создания или оператор к R объекту. Вместе<br>с тем концепция эта очень важна.<br><br>Должна быть проявлена некоторая осторожность при назначении или удалении<br>атрибутов, поскольку они являются неотъемлемой частью используемой в R<br>системы объектов.<br><br>Когда такое используют в левой части присваивания, оно может быть<br>использовано, чтобы связать новый атрибут с объектом или изменить<br>существующий. Например<br><br>&gt; attr(z, "dim") &lt;- c(10,10)<br><br>позволяет R рассматривать z, как если бы это была матрица 10-на-10.<br><br>3.4 Класс объекта<br><br>Все объекты в R имеют класс, определяемый при помощи функции class.<br>Для простых векторов это только тип, например, "numeric", "logical",<br>"character" или "list", но возможны и другие значения "matrix", "array",<br>"factor" и " data.frame".<br><br>Специальный атрибут известный как класс объекта используется для<br>обеспечения объектно-ориентированного стиля сноска12 программирования в<br>R. Например, если объект имеет класс "data.frame", он будет напечатан<br>определенным способом, plot() функция будет отображать его графически<br>определенным способом, и другие так называемые общие функции, таких как<br>summary() будут реагировать на него как параметр, способом применимым<br>к данному классу.<br><br>Чтобы удалить временно эффект класса, используйте функцию unclass().<br>Например, если winter класса "data.frame", тогда<br><br>&gt; winter<br><br>будет выведена в виде таблицы данных, которая выглядит подобно матрице,<br>тогда как<br><br>&gt; unclass(winter)<br><br>выведет его как обычный список. Только в особых ситуациях, понадобится<br>использовать эту возможность, но она нужна когда Вы учитесь, что бы<br>разбираться с понятиями класса и общих функций.<br><br>4 Упорядоченные и неупорядоченные факторы<br><br>Фактором является векторный объект, используемый для указания дискретной<br>классификации (группировки) компонентов других векторов той же длины. R<br>поддерживает упорядоченные и неупорядоченные факторы. Хотя "реальные"<br>применения факторов это формулы моделей (см. Контрасты), мы здесь<br>рассмотрим специальный пример.<br><br>4.1 Специальный пример<br><br>Предположим, к примеру, мы имеем выборку 30 налоговых деклараций из всех<br>штатов и территорий Австралии сноска13, и их индивидуальное происхождение<br>определяет символьный вектор абревиатуры штата, как<br><br>&gt; state &lt;- c("tas", "sa", "qld", "nsw", "nsw", "nt", "wa", "wa", "qld",<br>"vic", "nsw", "vic", "qld", "qld", "sa", "tas", "sa", "nt", "wa", "vic",<br>"qld", "nsw", "nsw", "wa", "sa", "act", "nsw", "vic", "vic", "act")<br><br>Заметьте, что в случае символьного вектора, "sorted" означает<br>отсортировано в алфавитном порядке.<br><br>Создаются факторы аналогичным образом с помощью функции factor():<br><br>&gt; statef &lt;- factor(state)<br><br>Функция print() обрабатывает факторы несколько по другому, чем другие<br>объекты:<br><br>&gt; statef<br><br>[1] tas sa qld nsw nsw nt wa wa qld vic nsw vic qld qld sa<br><br>[16] tas sa nt wa vic qld nsw nsw wa sa act nsw vic vic act<br><br>Levels: act nsw nt qld sa tas vic wa<br><br>Чтобы выяснить уровни фактора может быть использована функция levels().<br><br>&gt; levels(statef)<br><br>[1] "act" "nsw" "nt" "qld" "sa" "tas" "vic" "wa"<br><br>4.2 функция tapply() и неровные массивы<br><br>Чтобы продолжить предыдущий пример, предположим, что мы имеем доходы<br>от каждого налогоплательщика в отдельном векторе (в подходящих крупных<br>денежных единицах)<br><br>&gt; incomes &lt;- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56, 61,<br>61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46, 59, 46, 58, 43)<br><br>Для расчета выборочного среднего дохода для каждого штата мы теперь<br>сможем использовать специальную функцию tapply():<br><br>&gt; incmeans &lt;- tapply(incomes, statef, mean)<br><br>дает вектор средних из маркированных по уровням компонентов<br><br>act nsw nt qld sa tas vic wa<br><br>44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250<br><br>Функция tapply() используется для применения функции, в этом случае<br>mean(), к каждой группе компонентов первого аргумента, в этом случае<br>incomes, определенных уровнями второго компонента, в этом случае statef<br>сноска14, как если бы они были отдельными векторными структурами. В<br>результате получится структура такой же длины, содержащая результаты,<br>как длина свойства levels фактора. За подробностями читателю следует<br>обратится к документации.<br><br>Предположим далее нам понадобится расчитать стандартные ошибки среднего<br>дохода штатов. Для этого нам нужно написать функцию R для расчета<br>стандартной ошибки для любого заданного вектора. Поскольку имеется<br>встроенная функция var() для расчета выборочной вариации, такая функция<br>очень простой однострочник, задаваемая присваиванием:<br><br>&gt; stderr &lt;- function(x) sqrt(var(x)/length(x))<br><br>(Написание функций будет рассмотрено позднее в "Написание ваших<br>собственных функций", и в данном случае является избыточным, поскольку<br>R имеет уже встроенную функцию sd().) После проведенного присваивания,<br>стандартные ошибки рассчитываются путем<br><br>&gt; incster &lt;- tapply(incomes, statef, stderr)<br><br>и вычисленные значения равны<br><br>&gt; incster<br><br>act nsw nt qld sa tas vic wa<br><br>1.5 4.3102 4.5 4.1061 2.7386 0.5 5.244 2.6575<br><br>В качестве упражнения позаботьтесь о определении стандартных 95% границ<br>для средних доходов штатов. Для этого можно использовать tapply() еще раз<br>с функцией length(), что бы найти размер выборки, и qt() функцией что бы<br>найти значение точек процентов соответствующего t-распределения. (Можно<br>также исследовать возможности R в t-тестах.)<br><br>Функция tapply() может также использоваться для обработки более сложного<br>индексирования вектора на несколько категорий. Например, мы могли бы<br>захотеть разделить налогоплательщиков одновременно по штату и полу. Однако<br>в данном простом случае (только одного фактора), то что произойдет, можно<br>представить следующим образом. Значения в векторе собираются в группы,<br>соответствующие различным позициям в факторе. Затем функция применяется<br>для каждой из этих групп в отдельности. Результат это вектор значений<br>функции, маркированный согласно значению levels фактора.<br><br>Сочетание вектора и фактора меток является примером того, что иногда<br>называют неровным массивом, поскольку размеры подклассов возможно не<br>одинаковы. Когда размеры подкласса все одинаковы индексация может быть<br>организована косвенным образом и гораздо более производительно, что мы<br>увидим в следующем разделе.<br><br>4.3 Упорядоченные факторы<br><br>Уровни факторов хранятся в алфавитном порядке, или в порядке, в каком<br>они были определены в факторе, если они были определены принудительно.<br><br>Иногда уровни будут иметь естественный порядок, который нужен для<br>регистрации данных и который мы хотим использовать в нашем статистическом<br>анализе. Функция ordered() создает такой упорядоченный фактор, во<br>всем остальном идентичный просто фактору. Для большинства применений,<br>единственным различием между упорядоченным и неупорядоченным фактором<br>является то, что первые выводятся на печать согласно порядку уровней,<br>однако контрасты создаваемые из них при подгонке линейных моделей<br>различны.<br><br>5.1 Массивы<br><br>Массив можно рассматривать как многократно пронумерованное собрание<br>записей данных, например, чисел. R облегчает требования к созданию и<br>обработке массивов и, в частности, их специальной разновидности матриц.<br><br>Вектор размерности это вектор из неотрицательных целых. Если его<br>длина k, тогда у массива k измерений, например матрица это 2х-мерный<br>массив. Размерности индексируются от единицы до значений, заданных в<br>векторе размерностей.<br><br>Вектор может быть использован в R как массив, только если он в качестве<br>своего свойства dim имеет вектор размерностей. Предположим, например,<br>z - вектор из 1500 элементов. Присвоение<br><br>&gt; dim(z) &lt;- c(3,5,100)<br><br>назначает ему свойство dim, что позволяет вектору использоваться как<br>массив 3 на 5 на 100.<br><br>Другие функции, такие, как matrix() и array(), служат для более просто<br>и естественно выглядящего присвоения, как мы увидим в функции array().<br><br>Значения вектора данных задают значения массива в таком же порядке,<br>как они происходят в FORTRAN, что означает "столбцы более старшие",<br>первый индекс сдвигается быстрее всех, а последний медленнее всех.<br><br>Например, если вектор размерностей массива, скажем a, это с(3,4,2),<br>то имеется 3 * 4 * 2 = 24 записи в a, и вектор данных содержит их в<br>порядке a[1,1,1], a[2,1,1], ..., a[2,4,2], a[3,4,2].<br><br>Массивы могут быть одномерными: такие массивы, как правило, обрабатываются<br>так же, как векторы (в том числе при печати), однако может возникнуть<br>путаница с исключениями из правил.<br><br>5.2 Индексация массивов. Подмножества массивов<br><br>Отдельные элементы массива могут быть адресованы указанием названия<br>массива сопровождающемся разделенным запятыми индексом в квадратных<br>скобках.<br><br>В целом, подмножество массива может быть указано последовательностью<br>индексных векторов в позициях индекса; причем если какой нибудь позиции<br>индекса назначается пустой индексный вектор, то включается весь диапазон<br>данного индекса.<br><br>Продолжая предыдущий пример, a[2,,] - это 4 * 2 массив с с вектором<br>размерности c(4,2) и вектором данных, содержащим значения<br><br>c(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1], a[2,1,2], a[2,2,2], a[2,3,2],<br>a[2,4,2])<br><br>в указанном порядке. a[,,] соответствует всему массиву, что то же самое,<br>что опустить индексы полностью и использовать a без них.<br><br>Для любого массива, скажем Z, вектор размерностей может быть адресован<br>напрямую как dim(Z) (по обе стороны операции присвоения).<br><br>Итак, если имя массива приводится лишь с одним индексом или индексным<br>вектором, то используются только соответствующие значения вектора данных;<br>в этом случае вектор размерности игнорируется. Это не относится, однако,к<br>случаю когда одиночный индекс не вектор, а сам является массивом, далее<br>мы обсудим это.<br><br>5.3 Матрицы индексов<br><br>В любой позиции индекса, как и векторный индекс, может использоваться<br>матрица, в виде одиночной индексной матрицы, с тем что бы: либо назначить<br>качественный вектор нерегулярному набору элементов в массиве, либо<br>выделить нерегулярный набор в виде вектора.<br><br>Следующий матричный пример позволит разъяснить процесс. В случае массива<br>с двойным индексом, индексная матрица может быть задана, состоящей из<br>двух колонок и стольких строк, сколько необходимо. Записями в индексной<br>матрице являются строки и столбцы индексов для дважды проиндексированного<br>массива. Предположим, например, мы имеем 4 на 5 массив X, и мы хотели<br>бы сделать следующее:<br><br>* Извлечь элементы X[1,3], X[2,2] и X[3,1], как векторную структуру, и<br><br>* Замените эти записи в массиве X на нулями.<br><br>В этом случае нам понадобится 3 на 2 индексный массив, как показано в<br>следующем примере.<br><br>&gt; x &lt;- array(1:20, dim=c(4,5)) # Создает массив 4 на 5.<br><br>&gt; x<br><br>[,1] [,2] [,3] [,4] [,5]<br><br>[1,] 1 5 9 13 17<br><br>[2,] 2 6 10 14 18<br><br>[3,] 3 7 11 15 19<br><br>[4,] 4 8 12 16 20<br><br>&gt; i &lt;- array(c(1:3,3:1), dim=c(3,2))<br><br>&gt; i # i это индексный массив 3 на 2.<br><br>[,1] [,2]<br><br>[1,] 1 3<br><br>[2,] 2 2<br><br>[3,] 3 1<br><br>&gt; x[i] # Извлечь указанные элементы<br><br>[1] 9 6 3<br><br>&gt; x[i] &lt;- 0 # Заменить указанные элементы нулями.<br><br>&gt; x<br><br>[,1] [,2] [,3] [,4] [,5]<br><br>[1,] 1 5 0 13 17<br><br>[2,] 2 0 10 14 18<br><br>[3,] 0 7 11 15 19<br><br>[4,] 4 8 12 16 20<br><br>Отрицательные индексы не разрешены в индекс матрицах. NA и нулевые<br>значения допускаются: строки в индекс матрице, содержащие ноль<br>игнорируются, а строки, содержащие NA порождают в результате NA.<br><br>Как менее тривиальный пример, предположим, что мы хотим создать<br>(нередуцированную) матрицу дизайна для блочного дизайна заданного блоками<br>факторов (b уровней) и вариаций (v уровней). Далее предположим, есть n<br>участков в эксперименте. Мы могли бы действовать следующим образом:<br><br>&gt; Xb &lt;- matrix(0, n, b)<br><br>&gt; Xv &lt;- matrix(0, n, v)<br><br>&gt; ib &lt;- cbind(1:n, blocks)<br><br>&gt; iv &lt;- cbind(1:n, varieties)<br><br>&gt; Xb[ib] &lt;- 1<br><br>&gt; Xv[iv] &lt;- 1<br><br>&gt; X &lt;- cbind(Xb, Xv)<br><br>Для построения матрицы инцидентности, например N, мы могли бы использовать<br><br>&gt; N &lt;- crossprod(Xb, Xv)<br><br>Однако простым прямым способом получения этой матрицы будет использовании<br>table():<br><br>&gt; N &lt;- table(blocks, varieties)<br><br>Индекс матрицы должны быть численными: любые другие формы матриц<br>(например логические или символьные матрицы) использованные в качестве<br>индекса рассматривается как индексные вектора.<br><br>5.4 Функция array()<br><br>Как и присвоением векторной структуре атрибута dim, массивы могут быть<br>так же изготовлены из вектора с помощью функции array, которая имеет форму<br><br>&gt; Z &lt;- array(data_vector, dim_vector)<br><br>Например, если вектор h содержит 24 или меньше чисел, тогда команда<br><br>&gt; Z &lt;- array(h, dim=c(3,4,2))<br><br>будет использовать h, что бы создать 3 на 4 на 2 массив в Z. Если размер<br>h - точно равен 24, результат тот же, как у<br><br>&gt; dim(Z) &lt;- c(3,4,2)<br><br>Однако если h короче, чем 24, ее значения рециркулируют с начала вновь что<br>бы дополнить его до размера 24 (см. Правило рециркуляции). Как крайний,<br>но распространенный случай<br><br>&gt; Z &lt;- array(0, c(3,4,2))<br><br>делает Z массивом из одних нулей.<br><br>На данный момент dim(Z) обозначает вектор размерностей c(3,4,2), и Z[1:24]<br>соответствует вектору данных, как это было в h, и Z[] с пустыми индексом<br>или Z без индекса означает весь массив целиком как массив.<br><br>Массивы могут использоваться в арифметических выражениях, результатом<br>является массив сформированный операциями элемент-за-элементом на<br>векторе данных. Параметры размерности операндов, как правило, требуются<br>одинаковые, и наследуются вектором размерности результата. Таким образом,<br>если A, B и C все подобные массивы, а затем<br><br>&gt; D &lt;- 2*A*B + C + 1<br><br>делает D подобным массивом, вектор данных которого является результатом<br>полученным поэлементными операциями. Однако точные правила о смешанных<br>вычислениях массивов и векторов должны быть рассмотрены чуть более<br>внимательно.<br><br>5.4.1 Смешанная арифметика векторов и массивов. Правило рециркуляции<br><br>Точные правила, касающиеся поэлементных смешанных расчетов с векторами<br>и массивами несколько экзотические и трудно находимые в документации.<br>Опытным путем мы обнаружили следующее надежное руководство.<br><br>* Выражение разбирается слева направо.<br><br>* Любой короткий векторный операнд продлевается повторением своих<br>значений, пока не будет соответствовать размеру каждого другого операнда.<br><br>* Как только встречаются короткий вектор с массивом, массив должен иметь<br>тот же значение размерности или произойдет ошибка.<br><br>* Любой вектор операнд более длинный, чем операнд матрица или массив<br>генерирует ошибку.<br><br>* Если имеется структура массив и не было ошибки или приведения к вектору,<br>результатом будет структура массив с значением dim общим с его массивами<br>операндами.<br><br>5.5 Внешнее произведение двух массивов<br><br>Важной операцией на массивах является внешнее произведение. Если a и<br>b два числовых массива, их внешнее произведение это массив, чей вектор<br>размерностей получают конкатенацией двух исходных векторов размерности<br>(порядок важен), а вектор данных получают получая все возможные<br>произведения элементов вектора данных a с элементами вектора данных<br>b. Внешнее произведение выполняет специальный оператор %о%:<br><br>&gt; ab &lt;- a %o% b<br><br>Альтернатива<br><br>&gt; ab &lt;- outer(a, b, "*")<br><br>Функцию умножения может быть заменена произвольной функцией двух<br>переменных. Например, если бы мы хотели вычислить функцию f(x; y) =<br>cos(y)/(1 + x^2) на регулярной сетке значений с х и у - координатами,<br>определенными R векторами х и у соответственно, мы могли бы действовать<br>следующим образом:<br><br>&gt; f &lt;- function(x, y) cos(y)/(1 + x^2)<br><br>&gt; z &lt;- outer(x, y, f)<br><br>В частности, внешнее произведение двух обычных векторов является<br>массив с двойным индексом (то есть матрица, ранга как минимум 1).<br>Заметьте, что оператор внешнего произведения, конечно, не коммутативный.<br>Определение собственной R функции будет рассмотрено далее в "Написание<br>ваших собственных функций".<br><br>Пример: детерминант 2 на 2 одноразрядных матриц<br><br>Как искусственный, но емкий пример, рассмотрим детерминант 2 на 2 матрицы<br>[a, b; c, d], где каждая запись является неотрицательным целым числом<br>в диапазоне 0, 1, ..., 9, то есть цифрой .<br><br>Задача заключается в поиске детерминантов, ad - bc, всех возможных<br>матриц этого вида, и представление частоты, с которой встречается<br>каждое значение, в виде графика плотности распределения. Это равносильно<br>нахождению распределения вероятности детерминантов, если каждая цифра<br>выбирается наугад независимо и равномерно.<br><br>Аккуратный способ, это использовать функцию outer() дважды:<br><br>&gt; d &lt;- outer(0:9, 0:9)<br><br>&gt; fr &lt;- table(outer(d, d, "-"))<br><br>&gt; plot(as.numeric(names(fr)), fr, type="h", xlab="Determinant",<br>ylab="Frequency")<br><br>Отметьте приведение значения names таблицы частот к numeric, с тем чтобы<br>восстановить диапазон значений детерминанта. "Очевидный" путь решения<br>этой проблемы через циклы, которые будут обсуждаться в "Циклы и условное<br>выполнение", настолько неэффективен, что просто нецелесообразен.<br><br>Кроме того, просто удивительно, что почти одна на 20 этих матриц является<br>сингулярной.<br><br>5.6. Обобщенное транспонирование массивов<br><br>Функция aperm(a, perm) может быть использована для перестановок<br>массива a. Аргумент perm должен быть перестановкой из целых (1, ...,<br>k), где k - число индексов в a. Вывод функции - массив того же размера,<br>но с учетом того, что perm[j] задала старым размерностям новые j-ные<br>измерения. Самый простой способ - думать об этой операции, как о обобщение<br>для транспонирования матриц. Действительно, если A это матрица, (то есть<br>массив с двойным индексом), то B полученный путем<br><br>&gt; B &lt;- aperm(A, c(2,1))<br><br>- это просто транспонированная А. Для этого особого случая есть простая<br>функция t(), поэтому мы могли бы использовать B &lt;- t().<br><br><br>5.7 Возможности обработки матриц<br><br>Как отмечалось выше, таблица - это просто массив с двумя индексами.<br>Однако он является таким важным особым случаем, что он достоин отдельного<br>обсуждения. R содержит много операторов и функций, которые доступны<br>только для матриц. Например, как указано выше, t(X) - это функция<br>транспонирования матрицы. Функции nrow(A) и ncol(A) выдают число строк<br>и столбцов в матрице соответственно.<br><br>* Умножение<br><br>* Линейные уравнения и инверсии<br><br>* Собственные значения и собственные вектора<br><br>* Сингулярное разложения и детерминант<br><br>* Подгонка методом наименьших квадратов и QR разложение<br><br>5.7.1 Умножение матриц<br><br>Оператор %*% используется для умножения матриц. n на 1 или 1 на n матрицы,<br>конечно, можно использовать в качестве n-вектора, если контекст будет<br>подходящий. И наоборот, векторы, которые участвуют в выражении матричного<br>умножения автоматически полагаются векторами строк или столбцов, как<br>подойдет для умножения, если это возможно (хотя это не всегда однозначно<br>возможно, как мы увидим позже).<br><br>Если, например, А и В квадратные матрицы одинакового размера, то<br><br>&gt; A * B<br><br>является матрицей произведений элемент на элемент, а<br><br>&gt; A %*% B<br><br>является произведением матриц. Если х - вектор, то<br><br>&gt; х %*% A %*% х<br><br>является квадратичной формой. сноска15<br><br>Функция crossprod() формирует "векторное произведение", значит что<br>crossprod(X, у) тоже самое, что t(X) %*% y, но как операция более<br>эффективна. Если второй аргумент crossprod() пропущен, он принимается<br>таким же, как первый.<br><br>Смысл diag() зависит от ее аргументов. diag(v), где v - вектор,<br>дает диагональную матрицу с элементами вектора, в качестве значений<br>диагонали. С другой стороны diag(М), где M - это матрица, дает вектор<br>значений главной диагонали М. Это те же умолчания, которые используются<br>для diag() в Matlab. Кроме того, что несколько неожиданно, если k это<br>одиночное числовое значение, тогда diag(k) - это k на k единичная матрица!<br><br>5.7.2 Линейные уравнения и обращение<br><br>Решение линейных уравнений является обращенным произведением матриц.<br>Когда после<br><br>&gt; b &lt;- A %*% x<br><br>даны только A и b, вектор х является решением этой системы линейных<br>уравнений. В R,<br><br>&gt; solve(A,b)<br><br>решает систему, возвращая х (с некоторой потерей точности). Заметим,<br>что в линейной алгебре, формально x = A^{-1} %*% b, где A^{-1} обозначает<br>обращение A, что можно вычислить с помощью<br><br>solve(A)<br><br>, однако редко требуется. Численно, это неэффективные и потенциально<br>нестабильно вычислять x &lt;- solve(A) %*% b вместо solve(A,b).<br><br>Квадратичная форма x %*% A^{-1} %*% x, которая используется в многомерных<br>расчетах, следует вычислять как то так сноска16 : x %*% solve(A,x),<br>а не вычисляя обращенную A.<br><br>5.7.3 Собственные значения и собственные вектора<br><br>Функция eigen(Sm) вычисляет собственное значение и собственный вектор<br>у симметричной матрицы Sm. Результатом этой функции является список из<br>двух компонентов называющихся values и vectors. Присвоение<br><br>&gt; ev &lt;- eigen(Sm)<br><br>будет присваивать этот список ev. Затем ev$val - вектор на собственных<br>значений Sm и ev$vec содержит матрицу соответствующих собственных<br>векторов. Если бы мы нуждались только в собственных значениях мы могли<br>бы использовать присвоение:<br><br>&gt; evals &lt;- eigen(Sm)$values<br><br>evals теперь содержит вектор собственных значений, а второй компонент<br>отбрасывается. Если выражение<br><br>&gt; eigen(Sm)<br><br>используется как команда, оба компонента выводятся, вместе с их<br>именами. Для больших матриц, лучше избегать вычисление собственных<br>значений, если они не нужны, используя выражение<br><br>&gt; evals &lt;- eigen(Sm, only.values = TRUE)$values<br><br>5.7.4 Метод сингулярного разложения и определитель<br><br>Функция svd(M) принимает произвольную матрицу как аргумент, M,<br>и подсчитывает сингулярное разложение М. Оно состоит из матрицы<br>ортонормальных столбцов U с теми же столбцами, как M, вторая матрица<br>ортонормальных столбцов V, чьи столбцы - это строки М и диагональная<br>матрица положительных записей D, таких, что M = U %*% D %*% t(V).<br>D фактически возвращается как вектор диагональных элементов. В результате<br>svd(М) фактически является списком из трех компонентов которые называют d,<br>u и v, соответственно.<br><br>Если M является квадратной, то, не трудно понять, что<br><br>&gt; absdetM &lt;- prod(svd(M)$d)<br><br>вычисляет абсолютное значение определителя М. Если такой расчет необходимо<br>проводить часто с различными матрицами, он может быть определен как<br>функция R<br><br>&gt; absdet &lt;- function(M) prod(svd(M)$d)<br><br>после чего мы можем использовать absdet(), как любую другую функцию R. Как<br>дальнейший тривиальный, но потенциально полезный пример, Вы возможно<br>решились бы написать функцию, скажем tr(), для расчета остатков квадратных<br>матриц. [Примечание: Вам не нужно явно использовать цикл. Взгляните еще<br>раз на функцию diag().]<br><br>R имеет встроенные функции для расчета определителя, включая sign,<br>и determinant, дающие знак и модуль (опционально в логарифмической шкале).<br><br>5.7.5 Подгонка методом наименьших квадратов и QR разложение<br><br>Функция lsfit() возвращает список содержащий результаты подгонки методом<br>наименьших квадратов. Присвоение, такое как<br><br>&gt; ans &lt;- lsfit(X, y)<br><br>дает результаты подгонки методом наименьших квадратов, где y - вектор<br>наблюдений, а Х матрица плана. См. руководство для получения более<br>подробной информации, а также про выполнение, помимо прочего, функции<br>ls.diag() для диагностики регрессии. Заметим, что общее среднее значение<br>автоматически включается, и не требует непосредственной вставки как<br>столбец X. Кроме того, знайте, что Вы почти всегда будете предпочитать<br>использовать lm(.) (См. линейные модели) вместо lsfit() в регрессионных<br>моделях.<br><br>Другой тесно связаной функцией является qr() и ее сателиты. Рассмотрим<br>следующие присвоения<br><br>&gt; Xplus &lt;- qr(X)<br><br>&gt; b &lt;- qr.coef(Xplus, y)<br><br>&gt; fit &lt;- qr.fitted(Xplus, y)<br><br>&gt; res &lt;- qr.resid(Xplus, y)<br><br>Это вычислит ортогональную проекцию y в диапазоне X в fit, проекцию на<br>ортогональное дополнение в res, и вектор коэффициентов для проецирования<br>в b, то есть в сущности b является результатом оператора Matlab '\'.<br><br>Не предполагается, что X имеет полный диапазон столбцов. Избыточность<br>будет разыскиваться, и как только найдена, устраняться.<br><br>Эта альтернатива является старым, низкоуровневым способом выполнить расчет<br>методом наименьших квадратов. Хотя это еще и используется в некоторых<br>случаях, это теперь повсеместно заменяется возможностями аппарата<br>статистических моделей, как будет показано в "Статистические модели в R".<br><br>5.8 Объединение частей матриц, cbind() и rbind()<br><br>Как мы уже увидели неформально, матрицы могут строиться из других<br>векторов и матриц с помощью функции cbind() и rbind(). Можно сказать<br>что cbind() формирует матрицы соединением вместе матриц по горизонтали,<br>или по-столбцам, а rbind() вертикально, или по-строчно.<br><br>В присвоении<br><br>&gt; X &lt;- cbind(arg_1, arg_2, arg_3, ...)<br><br>аргументы cbind () должены быть либо векторами любой длины, или матриц<br>с одинаковым размером колонки, то есть одинаковым количеством строк. В<br>результате матрица из объединения аргументов arg_1, arg_2, ... образующих<br>столбцы.<br><br>Если некоторые аргументы cbind() являются векторами они могут быть<br>короче, чем столбцы любой из имеющихся матрицы, и в этом случае они<br>циклически продлеваются до соответствия размера столбцу матрицы (или<br>длине наибольшего вектора, если используются не матрицы).<br><br>Функция rbind() выполняет соответствующую операцию для строк. В этом<br>случае любой векторный аргумент, может циклически повторяться, конечно<br>же в качестве вектор-строки.<br><br>Предположим, X1 и X2 имеют одинаковое число строк. Чтобы совместить их<br>по-столбцам в матрице X, а также с первой колонке из единиц мы можем<br>использовать<br><br>&gt; X &lt;- cbind(1, X1, X2)<br><br>Результат rbind() или cbind() всегда имеет статус матрицы. Поэтому<br>cbind(х) и rbind(х) возможно простейший путь чтобы вектор х рассматривался<br>как столбец или строка матрицы соответственно.<br><br>5.9 Применение функции объединения с(), с массивами<br><br>Следует отметить, что в то время cbind() и rbind() являются функциями<br>объединения которые учитывают параметр dim, базовая функция c() не<br>учитывает, а наоборот снимает со всех численных объектов параметры dim<br>и dimnames. Это иногда по своему полезно.<br><br>Официальный способ привести массив обратно к простому векторному объекту<br>является использование as.vector()<br><br>&gt; vec &lt;- as.vector(X)<br><br>Однако аналогичный результат может быть достигнут путем использования с()<br>с только одним аргументом, просто из-за этого побочного эффекта:<br><br>&gt; vec &lt;- с(X)<br><br>Между ними есть незначительные различия, но в конечном итоге выбор<br>между ними во многом является вопросом стиля (предпочтительнее привычный<br>способ).<br><br>5.10 Частотные таблицы из факторов<br><br>Напоминаем, что фактор определяет разделение на группы. Аналогично<br>пара факторов определяет двумерную перекрестную классификацию, и<br>так далее. Функция table() дает частотную таблицу, которая может быть<br>вычислена от равных по длине факторов. Если заданы k аргументов-факторов,<br>в результате получаем k-мерный массив частот.<br><br>Предположим, например, что statef является фактором предоставления код<br>штата для каждого элемента вектора данных. Присвоение<br><br>&gt; statefr &lt;- table(statef)<br><br>дает в statefr таблицу частот каждого государства в выборке. Частоты<br>упорядочены и маркированны значениями levels фактора. Этот простой случай<br>эквивалентен, но удобнее, чем,<br><br>&gt; statefr &lt;- tapply(statef, statef, length)<br><br>Кроме того предположим, что incomef является фактором предоставляющим<br>соответствующее определение "вид доходов" для каждого элемента вектора<br>данных, например используя функцию cut():<br><br>&gt; factor(cut(incomes, breaks = 35+10*(0:7))) -&gt; incomef<br><br>Тогда для расчета двумерной таблицы частот:<br><br>&gt; table(incomef,statef)<br><br>statef<br><br>incomef act nsw nt qld sa tas vic wa<br><br>(35,45] 1 1 0 1 0 0 1 0<br><br>(45,55] 1 1 1 1 2 0 1 3<br><br>(55,65] 0 3 1 3 2 2 2 1<br><br>(65,75] 0 1 0 0 0 0 1 0<br><br>Расширение до многомерных частотных таблиц тривиально.<br><br>6.1 Списки<br><br>Список R - это объект состоящий из упорядоченного набора объектов<br>называемых компонентами списка.<br><br>Нет особой необходимости что бы компоненты были одинакового вида или типа,<br>к примеру - список может состоять из численного вектора, логического<br>значения, матрицы, комплексного вектора, символьного массива, функции,<br>и так далее. Вот простой пример как создать список:<br><br>&gt; Lst &lt;- list(name="Fred", wife="Mary", no.children=3,<br>child.ages=c(4,7,9))<br><br>Компоненты всегда пронумерованы и на них всегда можно сослаться по<br>номеру. Таким образом, если Lst - имя списка с четырьмя компонентами,<br>на них можно индивидуально сослаться Lst[[1]], Lst[[2]], Lst[[3]] и<br>Lst[[4]]. Если, далее, Lst [[4]] - это вектор индексный массив тогда<br>Lst[[4]][1] является его первой записью.<br><br>Если Lst - это список, то функция length(Lst) дает число имеющихся<br>(максимально) компонентов.<br><br>Составляющие списков можно также именовать, и в этом случае на компонент<br>можно сослаться либо с указанием названия компонента как символьной<br>строки вместо номера в двойных квадратных скобках, или, что более удобно,<br>предоставив в форме выражения<br><br>&gt; имя$имя_компонента<br><br>что даст тот же эффект.<br><br>Это очень полезное соглашение, так как упрощает получение нужного<br>компонента, когда вы забыли его номер.<br><br>Так в простом примере, приведенном выше:<br><br>Lst$name то же, что Lst[[1]] и это строка "Fred",<br><br>Lst$wife то же, что Lst[[2]] и это строка "Mary",<br><br>Lst $ child.ages [1] такая же, как Lst [[4]] [1], и это число 4.<br><br>Кроме того, можно также использовать имена компонентов списка в двойных<br>квадратных скобках, т.е. Lst[["название"]] то же, что Lst$название. Это<br>особенно полезно, когда имя извлекаемого компонента хранится в другой<br>переменной, к примеру<br><br>&gt; x &lt;- "name"; Lst[[x]]<br><br>Очень важно различать Lst[[1]] от Lst[1]. `[[...]]' является оператором<br>используемым для выбора одиночного элемента, а `[...]' это основной<br>индекс-оператор. Таким образом, первый случай - это первый объект в списке<br>Lst, и если это именованый спиок имя не включается. Второй случай дает<br>подсписок из списка Lst состоящий только из первой записи. Если это был<br>именованный список, имена передаются в подсписок.<br><br>Имена компонентов могут быть сокращенны до минимального числа букв<br>необходимых чтобы определить их уникально. Так Lst$coefficients может<br>быть минимально определяется как Lst$coe и Lst$covariance как Lst$cov.<br><br>Вектор имен является просто параметром списка, подобно любому другому,<br>и может использоваться как таковой. Другие структуры, помимо списков,<br>могут, конечно, подобным образом также иметь параметр имен.<br><br><br>6,2 Составление и изменение списков<br><br>Новые списки могут создаваться из существующих объектов функций<br>list(). Назначение вида<br><br>&gt; Lst &lt;- list(name_1=object_1, ..., name_m=object_m)<br><br>устанавливает список Lst из m компонентов используя object_1, ...,<br>object_m для компонентов и предоставления им имена, определенные<br>параметром names, (которые могут быть выбраны произвольно). Если эти имена<br>не упоминаются, компоненты только нумеруются. Компоненты, использованные<br>для формирования списка, копируются при создании нового списка и исходные<br>объекты не затрагиваются.<br><br>Списки, как и любой индексированный объект, может быть продлены указанием<br>дополнительных компонентов. Например<br><br>&gt; Lst[5] &lt;- list(matrix=Mat)<br><br>6.2.1 Объединение списков<br><br>Когда функции объединения с() получает списки аргументы, то результат<br>также является объектом типа список, компоненты которого это списки<br>аргументы объединенные друг с другом в последовательность.<br><br>&gt; list.ABC &lt;- c(list.A, list.B, list.C)<br><br>Напоминаем, что с векторными объектами, в качестве аргументов, аналогично<br>все аргументы в функции конкатенации объединяются в единую векторную<br>структуру. В этом случае все другие атрибуты, такие, как параметр<br>размерности, отбрасываются.<br><br><br>6.3 Таблицы данных<br><br>Таблицы данных это список класса "data.frame". На списки, которые могут<br>быть внесены в таблицы данных есть ограничения, а именно<br><br>* Компоненты должны быть векторами (численные, символьные, или<br>логические), факторами, численными матрицами, списками, или другими<br>таблицами данных.<br><br>* Матрицы, списки, таблицы данных вводят столько переменных в созданную<br>таблицу данных, сколько у них столбцов, элементов, или переменных,<br>соответственно.<br><br>* Численные и логические вектора, факторы включаются как есть, символьные<br>вектора приводят к факторам, уровни которых это уникальные значения,<br>встречающиеся в векторе.<br><br>* Вектор структуры выступающие как переменные таблиц данных должны<br>быть все одной длины, а матричные структуры должны все иметь одинаковый<br>размер строки.<br><br>Таблица данных может быть для многих целей рассматриваться как матрица<br>со столбцами, при необходимости, с различными типами и параметрами. Он<br>может быть выведен в виде матрицы, а его строки и столбцы, быть выделены<br>с использованием правил индексации матриц.<br><br><br>6.3.1 Создание таблиц данных<br><br>Объекты, удовлетворяющие ограничениям накладываемым на столбцы<br>(компоненты) в таблицах данных, могут использоваться для создания таблицы<br>данных, с помощью функции data.frame:<br><br>&gt; accountants &lt;- data.frame(home=statef, loot=incomes, shot=incomef)<br><br>Список компоненты которого соответствуют ограничениям таблиц<br>данных может быть приведен к таблице данных, при помощи функции<br>as.data.frame(). Простейший способ построить таблицу данных с нуля<br>заключается в использовании функции read.table() для чтения всей таблицы<br>данных из внешнего файла. Это обсуждается далее в "Чтение данных из<br>файлов".<br><br><br>6.3.2 attach() и detach()<br><br>Нотация с использованием $, такая как accountants$statef, для перечисления<br>компонентов, не так уж удобна. Полезной возможностью будет каким-то<br>образом сделать компоненты списка или таблицы данных временно видными,<br>как переменные под их собственными именами, без необходимости каждый<br>раз указывать прямо название списка.<br><br>Функция attach() принимает "базу данных", такую как список или таблицу<br>данных, как ее аргумент. Таким образом, предположим, lentils является<br>данных рамы с тремя переменными lentils$u, lentils$v, lentils$w. Подключая<br><br>&gt; attach(lentils)<br><br>помещает таблицу данных в путь поиска на позицию 2, и представляя<br>отсутствие каких-либо показателей u, v или w в позиции 1; у, v и<br>w делаются доступны в качестве переменных таблицы данных по особым<br>правилам. С этого момента такие присвоения, как<br><br>&gt; u &lt;- v+w<br><br>не заменяет компонент u таблицы данных, но маскирует ее другой переменной<br>u рабочего каталога на позиции 1 пути поиска. Для постоянных изменений<br>в самой таблице данных, самым простым способом является прибегнуть вновь<br>к $ обозначения:<br><br>&gt; lentils$u &lt;- v+w<br><br>Однако новое значение компонента u не видно до тех пор, пока таблица<br>данных не будет отсоединена и присоединена снова.<br><br>Чтобы отсоединить таблицу данных, используют функцию<br><br>&gt; detach()<br><br>Точнее, это выражение отсоединяет от пути поиска записи находящиеся в<br>настоящее время в позиции 2. Таким образом, в данном контексте переменные<br>u, v и w будут больше не видны, за исключением нотации списка, такой<br>как lentils$u и т.п.. Записи на позициях больше, чем 2 в пути поиска<br>можно отсоединить путем указания их номера в detach, но гораздо<br>безопаснее всегда использовать название, например, detach(lentils)<br>или detach("lentils")<br><br>Примечание: В R списки и таблицы данных могут быть присоединены только<br>в позиции 2 или выше, и то, что присоединено представляет собой копию<br>оригинального объекта. Вы можете изменить присоединенное значения<br>посредством присвоения, но первоначальный список или таблица данных<br>останется без изменений.<br><br><br>6.3.3 Работа с таблицами данных<br><br>Полезные правила, которые позволят вам одновременно комфортно работать<br>с различными проблемами в одном каталоге<br><br>* собрать все переменные для каждой четко определеной и отдельной проблемы<br>в таблицу данных под достаточно информативным именем;<br><br>* при работе с проблемой присоединять соответствующие таблицу данных<br>на позицию 2 и использовать рабочий каталог на уровне 1 для оперативных<br>значений и временных переменных;<br><br>* перед выходом из проблемы, добавить любые переменные, которые нужно<br>сохранить для будущего использования в таблицу данных, используя $<br>вид присвоения, а затем detach();<br><br>* наконец, устраните все нежелательные переменных из рабочего каталога<br>и сохраняйте его таким чистым от временных переменных, насколько это<br>возможно.<br><br>Таким образом очень просто работать со многими проблемами в общем<br>каталоге, во всех из которых есть переменных с названием х, у и z,<br>к примеру.<br><br><br>6.3.4 Прикрепление произвольных списков<br><br>atach() является общей функцией, которая позволяет присоединять к пути<br>поиска не только списки и таблицы данных, но и другие классы объектов. В<br>частности, любой объект типа "list" может присоединятся таким же образом:<br><br>&gt; attach(any.old.list)<br><br>Все, что было присоединено можно отделить используя detach, указывая<br>номер позиции или, что предпочтительнее, имя.<br><br><br>6.3.5 Управление путем поиска<br><br>Функция search показывает текущий путь поиска, и это очень полезный<br>способ отслеживать, какие таблицы данных и списки (а также пакеты)<br>были присоединены и отсоединены. Первоначально она дает<br><br>&gt; search()<br><br>[1] ".GlobalEnv" "Autoloads" "package:base"<br><br>, где. GlobalEnv является рабочее пространство. сноска17<br><br>После присоединения lentils мы имеем<br><br>&gt; search()<br><br>[1] ".GlobalEnv" "lentils" "Autoloads" "package:base"<br><br>&gt; ls(2)<br><br>[1] "u" "v" "w"<br><br>и, как мы видим, ls (или objects) могут быть использованы для изучения<br>содержимого любой позиции в пути поиска.<br><br>Наконец, мы отсоединяем таблицу данных и соглашаемся с его исключением<br>из пути поиска.<br><br>&gt; detach("lentils")<br><br>&gt; search()<br><br>[1] ".GlobalEnv" "Autoloads" "package:base"<br><br>7 Чтение данных из файлов<br><br>Большие объекты данных, как правило, будут заполнятся значениями из<br>внешних файлов, а не вводится с клавиатуры в ходе сессии R. Возможности<br>ввода R просты, и требования к их использованию достаточно строгие<br>и даже в определенной стапени негибкие. Существует четкая позиция<br>разработчиков R, что вы можете изменять ваши исходные данные с помощью<br>других инструментов, таких, как файловые редакторы или Perl1 сноска8<br>чтобы привести их к требованиям R. В большинстве случаев это очень просто.<br><br>Если переменные содержатся в основном в таблицах данных, как мы<br>настоятельно рекомендуем, целая таблица данных может быть считана напрямую<br>функцией read.table(). Существует также более примитивная функция ввода -<br>scan(), к которую можно обращаться напрямую.<br><br>Для получения дополнительной информации об импорте данных в R, а также<br>о экспорте данных, см. руководство "Импорт/экспорт данных в R".<br><br><br>7.1 Функция read.table()<br><br>Что бы напрямую считать целиком таблицу данных, внешний файл, как правило,<br>должен иметь специальную форму.<br><br>* В первая строка файла должна содержать имя для каждой переменной в<br>таблице данных.<br><br>* Каждая дополнительная строка в файле имеет в качестве первого компонента<br>метку строки и значения для каждой из переменных.<br><br>Если файл имеет на один компонент меньше в первой строке, чем во второй,<br>такое случай считается допустимым. Поэтому первые несколько строк из<br>файла считываемого в таблицу данных могут выглядеть следующим образом.<br><br><br>Вид входного файла с именами и метками строк:<br><br><br>Price Floor Area Rooms Age Cent.heat<br><br>01 52.00 111.0 830 5 6.2 no<br><br>02 54.75 128.0 710 5 7.5 no<br><br>03 57.50 101.0 1000 5 4.2 no<br><br>04 57.50 131.0 690 6 8.8 no<br><br>05 59.75 93.0 900 5 1.9 yes<br><br>...<br><br>По умолчанию численные компоненты (за исключением меток строк) считываются<br>как численные переменные, а не численные переменные, такие как Cent.heat<br>в примере, как факторы. В случае необходимости это может быть изменено.<br><br>Функция read.table() может использоваться для непосредственного чтения<br>таблицы данных<br><br>&gt; HousePrice &lt;- read.table ("houses.data")<br><br>Зачастую вам нужно будет избежать прямого ввода меток строк и использовать<br>стандартные метки строк по умолчанию. В этом случае файл может пропустить<br>столбец меток строк, как это сделано в следующем примере.<br><br>Входной файл форме без меток строк:<br><br>Price Floor Area Rooms Age Cent.heat<br><br>52.00 111.0 830 5 6.2 no<br><br>54.75 128.0 710 5 7.5 no<br><br>57.50 101.0 1000 5 4.2 no<br><br>57.50 131.0 690 6 8.8 no<br><br>59.75 93.0 900 5 1.9 yes<br><br>...<br><br>Таблица данных может быть считана так<br><br>&gt; HousePrice &lt;- read.table("houses.data", header=TRUE)<br><br>, где параметр header=TRUE указывает, что первая строка - строка названий,<br>и, как следует косвенно из вида файла, нет прямо заданных меток строк.<br><br>7.2 Функция scan()<br><br>Предположим, что вектора данных имеют одинаковую длину и считываются<br>параллельно. Далее предположим, что есть три вектора, первый символьного<br>типа и оставшиеся два численного типа, а файл это input.dat. Первым шагом<br>является использование scan() для считывания трех векторов в виде списка<br>следующим образом<br><br>&gt; inp &lt;- scan("input.dat", list("",0,0))<br><br>Второй аргумент является фиктивной списочной структурой, которая задает<br>тип считываемых трех векторов. В результате, сохраненным в inp, - получен<br>список, компоненты которого являются три считанных вектора. Для разделения<br>данных на три отдельных векторов, используем назначение, наподобие<br><br>&gt; label &lt;- inp[[1]]; x &lt;- inp[[2]]; y &lt;- inp[[3]]<br><br>Более удобно, чтобы фиктивный список имел поименованные компоненты,<br>в этом случае имена могут использоваться для доступа к считанным<br>векторам. Например<br><br>&gt; inp &lt;- scan("input.dat", list(id="", x=0, y=0))<br><br>Если Вы хотите получить доступ к переменным по отдельности, они могут<br>быть реорганизованы в переменные текущей таблицы данных:<br><br>&gt; label &lt;- inp$id; x &lt;- inp$x; y &lt;- inp$y<br><br>или список может быть присоединен в позицию 2 пути поиска<br>(см. "Присоединение произвольных списков").<br><br>Если второй аргумент является одиночным значением, а не списоком,<br>считывается единый вектор, все компоненты которого должны быть одного<br>типа, как и фиктивное значение.<br><br>&gt; X &lt;- matrix(scan("light.dat", 0), ncol=5, byrow=TRUE)<br><br>Есть и более развитые возможности ввода, они подробно описаны в<br>руководствах.<br><br>7.3 Доступ к встроенным наборам данных<br><br>Около 100 наборов данных поставляются с R (в наборах данных пакетов),<br>доступны в расширениях R (в том числе в рекомендованных расширениях<br>поставлямых с R). Чтобы просмотреть список доступных в настоящее время<br>наборов данных используйте<br><br>data()<br><br>С R версии 2.0.0 всех наборы данных поставляемые с R доступны<br>непосредственно по имени. Однако многие пакеты все еще используют старый<br>стиль, в котором data также использовалась для загрузки данных в R,<br>например<br><br>data(infert)<br><br>, и это может все еще быть использовано со стандартными расширениями<br>(как в этом примере). В большинстве случаев это будет загружать в R<br>объект с тем же названием. Однако, в некоторых случаях загружается<br>несколько объектов, поэтому смотрите встроенную помощь, чтобы узнать,<br>что ожидать в конкретном случае.<br><br>7.3.1 Загрузка данных из других пакетов R<br><br>Для доступа к данным из конкретного пакета, используйте опцию package,<br>например<br><br>data(package="rpart")<br><br>data(Puromycin, package="datasets")<br><br>Если пакет был присоединен библиотекой функций, ее наборы данных,<br>автоматически включаются в путь поиска.<br><br>Пакеты созданные пользователями могут послужить богатым источником<br>наборов данных.<br><br>7.4 Редактирование данных<br><br>Если начать редактировать таблицу данных или матрицу, для редактирования<br>запускается отдельное, похожее на электронную таблицу, окружение. Это<br>удобно для внесения небольших изменений после считывания набора<br>данных. Команда<br><br>&gt; xnew &lt;- edit(xold)<br><br>позволит вам изменить ваш набор данных xold, и по завершении измененый<br>объект присваивается xnew. Если вы хотите изменить сам набор данных xold,<br>самым простым способом является использование fix(xold), что эквивалентно<br>xold &lt;- edit(xold).<br><br>Используйте<br><br>&gt; xnew &lt;- edit(data.frame())<br><br>чтобы вводить данные через табличный интерфейс.<br><br>8 Распределение вероятности<br><br>* R как набор статистических таблиц<br><br>* Изучение распределения выборки данных<br><br>* Тесты для одной и двух выборок<br><br>8.1 R как набор статистических таблиц<br><br>Один удобный способ использовать R - наличие полного набора статистических<br>таблиц. Предусмотрены функции для вычисления кумулятивных функций<br>распределения P(X &lt;= х), функции плотности вероятности и квантильные<br>функции (задано q, найдено наименьший х такой, что P(X &lt;= х) &gt; q),<br>и генерирование выборки по заданному распределению.<br><br>Распределение R-наименование дополнительные аргументы<br><br>бета beta shape1, shape2, ncp<br><br>биноминальное binom size, prob<br><br>Каучи-Лоренса cauchy location, scale<br><br>хи-квадрат chisq df, ncp<br><br>экспоненциальное exp rate<br><br>F f df1, df2, ncp<br><br>гамма-распределение gamma shape, scale<br><br>геометрическое geom prob<br><br>гипергеометрическое hyper m, n, k<br><br>лог-нормальное lnorm meanlog, sdlog<br><br>логистическое logis location, scale<br><br>negative binomial nbinom size, prob<br><br>нормальное norm mean, sd<br><br>Пуассона pois lambda<br><br>t Стьюдента t df, ncp<br><br>равномерное unif min, max<br><br>Вейбулла weibull shape, scale<br><br>Уилкса wilcox m, n<br><br>Задать префикс 'd' названию для получения плотности, 'р' для кумулятивной<br>плотности распредения, 'q' для квантильной функции и 'r' для генерации<br>(случайная выборка). Первый аргумент х для dxxx, q для pxxx, р для qxxx<br>и n для rxxx (за исключением rhyper и rwilcox, для которых задается nn).<br>На настоящий момент не во всех случаях доступен параметр нецентральности<br>ncp: см. интерактивную справочную информацию.<br><br>Все pxxx и qxxx функции имеют логические аргументы lower.tail и log.p и<br>только dxxx из них имеет параметр log. Это позволяет, например, получение<br>кумулятивных (или "интегральной") функции риска, H(t) = - log(1 - F(t)),<br>с помощью<br><br>- pxxx(t, ..., lower.tail = FALSE, log.p = TRUE)<br><br>или более точно непосредственно log-likelihoods (с помощью dxxx(...,<br>log = TRUE)).<br><br>Кроме того, существуют функции ptukey и qtukey для распределения<br>преобразованного по Стьюденту разброса выборок из нормального<br>распределения.<br><br>Вот некоторые примеры<br><br>&gt; ## 2-стороннее р-значения для t распределения<br><br>&gt; 2*pt(-2.43, df = 13)<br><br>&gt; ## верхняя 1% точка для распределения F(2, 7)<br><br>&gt; qf(0.01, 2, 7, lower.tail = FALSE)<br><br><br>8.2 Изучение распределения набора данных<br><br>Получив (одномерный) набор данных, мы можем изучить его распределение<br>многими способами. Самый простой состоит в изучении чисел. Два<br>немного разных анализа производятся summary и fivenum с одной стороны,<br>и отображением чисел в консоли с помощью stem с другой (от названия<br>графика "stem and leaf").<br><br>&gt; attach(faithful)<br><br>&gt; summary(eruptions)<br><br>Min. 1st Qu. Median Mean 3rd Qu. Max.<br><br>1.600 2.163 4.000 3.488 4.454 5.100<br><br>&gt; fivenum(eruptions)<br><br>[1] 1.6000 2.1585 4.0000 4.4585 5.1000<br><br>&gt; stem(eruptions)<br><br>Десятичная точка - 1 разряд(ы) с левой стороны от |<br><br>16 | 070355555588<br><br>18 | 000022233333335577777777888822335777888<br><br>20 | 00002223378800035778<br><br>22 | 0002335578023578<br><br>24 | 00228<br><br>26 | 23<br><br>28 | 080<br><br>30 | 7<br><br>32 | 2337<br><br>34 | 250077<br><br>36 | 0000823577<br><br>38 | 2333335582225577<br><br>40 | 0000003357788888002233555577778<br><br>42 | 03335555778800233333555577778<br><br>44 | 02222335557780000000023333357778888<br><br>46 | 0000233357700000023578<br><br>48 | 00000022335800333<br><br>50 | 0370<br><br>График "стебли-и-листья" подобен гистограмме, в R есть функция hist для<br>постоения гистограммы.<br><br>&gt; hist(eruptions)<br><br>## сделать столбцы меньше, вывести плотность распределения<br><br>&gt; hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)<br><br>&gt; lines(density(eruptions, bw=0.1))<br><br>&gt; rug(eruptions) # show the actual data points<br><br>Больше элегантный график плотности распределения может быть сделан<br>с помощью density, и мы добавили в этом примере линию вычисленную<br>density. Окно bw было выбрано методом проб и ошибок поскольку окно по<br>умолчанию дает слишком сильное сглаживание (оно обычно делается для<br>"интересных" плотности). (Доступны и лучше автоматизированные методы<br>выбора окна, и в нашем примере bw="SJ" дает хороший результат.)<br><br>Мы можем вывести эмпирическую кумулятивную функцию распределения с<br>помощью функции ecdf.<br><br>&gt; plot(ecdf(eruptions), do.points=FALSE, verticals=TRUE)<br><br>Очевидно что это распределение далеко от любого стандартного<br>распределения. Как насчет горба справа, отражающего извержения длившиеся<br>дольше чем 3 минуты? Давайте подгоним соответствующее нормальное<br>распределение и наложим на результат подгонки кумулятивной функции<br>распределения.<br><br>&gt; long &lt;- eruptions[eruptions &gt; 3]<br><br>&gt; plot(ecdf(long), do.points=FALSE, verticals=TRUE)<br><br>&gt; x &lt;- seq(3, 5.4, 0.01)<br><br>&gt; lines(x, pnorm(x, mean=mean(long), sd=sqrt(var(long))), lty=3)<br><br>Quantile-quantile (Q-Q) график может помочь нам изучить это более<br>тщательно.<br><br>par(pty="s") # организует квадратную область графического вывода<br><br>qqnorm(long); qqline(long)<br><br>что показывает разумную соответствие, однако правый хвост короче, чем<br>можно было бы ожидать от нормального распределения. Давайте сравним это<br>с некоторыми смоделированными данными t распределения<br><br>х &lt;- rt (250, df = 5)<br><br>qqnorm (х); qqline (х)<br><br>они обычно (если это была случайная выборка) показывают большие хвосты,<br>чем это ожидалось для нормального распределения. Мы можем сделать Q-Q<br>график на полученном распределении<br><br>qqplot(qt(ppoints(250), df = 5), x, xlab = "Q-Q plot for t dsn")<br><br>qqline(x)<br><br>Наконец, мы могли бы захотеть более формального критерия принятия<br>нормальности (или отклонения). R предоставляет тест Шапиро-Уилкса<br><br>&gt; shapiro.test(long)<br><br>Shapiro-Wilk normality test<br><br>data: long<br><br>W = 0.9793, p-value = 0.01052<br><br>и тест Колмогорова - Смирнова<br><br>&gt; ks.test (long, "pnorm", mean = mean(long), sd = sqrt(var(long)))<br><br>One-sample Kolmogorov-Smirnov test<br><br>data: long<br><br>D = 0.0661, p-value = 0.4284<br><br>alternative hypothesis: two.sided<br><br>(Заметим, что теория распределения здесь не валидна, так как мы оценили<br>параметры нормального распределения по той же выборки.)<br><br>8.3 Одно- и двух- выборочные тесты<br><br>До сих пор мы сравнивали единственную выборку с нормальным<br>распределением. Гораздо более общая операция это сравнить характеристики<br>двух выборок. Отметим, что все "классические" критерии в R, в том числе<br>используемые ниже, содержаться в расширении stats, которое обычно уже<br>загружено.<br><br>Рассмотрим следующие наборы данных об скрытой теплоте таяния льда (калл/г)<br>по Rice (1995, стр.490)<br><br>Method A: 79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97<br><br>80.05 80.03 80.02 80.00 80.02<br><br>Method B: 80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97<br><br>Boxplot обеспечивают простое графическое сравнение двух выборок.<br><br>A &lt;- scan()<br><br>79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97<br><br>80.05 80.03 80.02 80.00 80.02<br><br>B &lt;- scan()<br><br>80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97<br><br>boxplot(A, B)<br><br>он показывает, что первая группа тяготеет к более высоким результатам,<br>чем вторая.<br><br>Для проверки на равенство средних в этих двух образцов, мы можем<br>использовать независимый t-тест<br><br>&gt; t.test(A, B)<br><br>Welch Two Sample t-test<br><br>data: A and B<br><br>t = 3.2499, df = 12.027, p-value = 0.00694<br><br>alternative hypothesis: true difference in means is not equal to 0<br><br>95 percent confidence interval:<br><br>0.01385526 0.07018320<br><br>sample estimates:<br><br>mean of x mean of y<br><br>80.02077 79.97875<br><br>который свидетельствует о значительной разнице, принимая нормальность<br>распределения. По умолчанию функция R не предполагает равенства дисперсий<br>в обоих выборках (в отличие от аналогичной t.test функции в S-Plus ). Мы<br>можем использовать F-тест для проверки равенства дисперсий, при условии,<br>что обе выборки взяты из нормальной генеральной совокупности.<br><br>&gt; var.test(A, B)<br><br>F test to compare two variances<br><br>data: A and B<br><br>F = 0.5837, num df = 12, denom df = 7, p-value = 0.3938<br><br>alternative hypothesis: true ratio of variances is not equal to 1<br><br>95 percent confidence interval:<br><br>0.1251097 2.1052687<br><br>sample estimates:<br><br>ratio of variances<br><br>0.5837405<br><br>который не показывает присутствия существенного различия, и поэтому<br>мы можем использовать классические t-тесты, которые требуют наличия<br>равенства дисперсий.<br><br>&gt; t.test(A, B, var.equal=TRUE)<br><br>Two Sample t-test<br><br>data: A and B<br><br>t = 3.4722, df = 19, p-value = 0.002551<br><br>alternative hypothesis: true difference in means is not equal to 0<br><br>95 percent confidence interval:<br><br>0.01669058 0.06734788<br><br>sample estimates:<br><br>mean of x mean of y<br><br>80.02077 79.97875<br><br>Все эти тесты требуют нормальность обоих выборок. Двух выборочный тест -<br>Уилкокса (он же Манна-Уитни) предполагает для нулевой гипотезы только<br>единое непрерывное распределение.<br><br>&gt; wilcox.test(A, B)<br><br>Wilcoxon rank sum test with continuity correction<br><br>data: A and B<br><br>W = 89, p-value = 0.007497<br><br>alternative hypothesis: true location shift is not equal to 0<br><br>Warning message:<br><br>Cannot compute exact p-value with ties in: wilcox.test(A, B)<br><br>Обратите внимание на предупреждение: есть несколько пучностей в каждой<br>выборке, которые сильно свидетельствуют, что эти данные взяты из<br>дискретного распределения (возможно это из-за округления).<br><br>Есть несколько способов визуально сравнить два образца. Мы уже видели<br>парный boxplot. Следующим<br><br>&gt; plot(ecdf(A), do.points=FALSE, verticals=TRUE, xlim=range(A, B))<br><br>&gt; plot(ecdf(B), do.points=FALSE , verticals=TRUE, add=TRUE)<br><br>будут выведены две эмпирических кумулятивных функции распределения, а<br>qqplot построит Q-Q график по двум выборкам. Тест Колмогорова-Смирнова<br>основан на определении максимального вертикального расстояния между<br>двумя ecdf, предполагая распределение единым и непрерывным:<br><br>&gt; ks.test(A, B)<br><br>Two-sample Kolmogorov-Smirnov test<br><br>data: A and B<br><br>D = 0.5962, p-value = 0.05919<br><br>alternative hypothesis: two-sided<br><br>Warning message:<br><br>cannot compute correct p-values with ties in: ks.test(A, B)<br><br>9 Группировка, циклы и условное исполнение<br><br>* Группировка выражений<br><br>* Управляющие операторы<br><br>9.1 Группировка выражений<br><br>R язык выражений в том смысле, что только его команда типа функция или<br>выражение возвращает результат. Даже присвоение является выражением<br>результат которого присвоение значения, и оно может быть использовано<br>везде где может быть использовано любое другое выражение, в частности<br>возможно множественное присвоение.<br><br>Команды могут быть сгруппированы скобками, {expr_1; ...; expr_m},<br>и в этом случае значением этой группы является результат последнего<br>выражения вычисленного в группе. Такая группа сама является выражением,<br>например она может быть включена в скобки, и использоваться как часть<br>еще большего выражения, и так далее.<br><br><br>9.2 Управляющие операторы<br><br>* Условное исполнение<br><br>* Повторяющееся выполнение<br><br><br>9.2.1 Условное исполнение: оператор if<br><br>В языке имеются условные конструкции в форме<br><br>&gt; if (expr_1) expr_2 else expr_3<br><br>где expr_1 должно вычислятся в одиночное логическое значение и результат<br>всего выражения является тогда очевиден.<br><br>Операторы "сокращения" &amp;&amp; и || часто используются как часть условия if<br>операторе. Тогда как &amp; и | применяются по-элементно к векторам, &amp;&amp; и ||<br>применяется к векторам единичной длины, и только вычисляют свой второй<br>аргумент, если это необходимо.<br><br>Существует векторизированный вариант if/else конструкции, это функция<br>ifelse. Она имеет форму ifelse(condition, a, b), и возвращает вектор<br>длины равной длинне его наибольшему аргументу, с элементами a[i], если<br>condition[i] истинно, в противном случае b[i].<br><br>9.2.2 Повторяющееся выполнение: для циклов, repeat и while<br><br>Итак для цикла имеется конструкция форма которой<br><br>&gt; for (name in expr_1) expr_2<br><br>где name - переменная цикла. expr_1 - векторное выражение, (часто<br>последовательность, подобная 1:20), часто expr_2 это сгруппированное<br>выражение, а составляющие его выражения написаны используя name. expr_2<br>вычисляются покругу следом за тем, как name движется по значениям в<br>векторе результате expr_1.<br><br>В качестве примера предположим, ind - вектор типа indicators, и мы<br>хотим подготовить отдельные графики y на х в каждой из групп. Одна<br>из возможностей заключается в использовании coplot(), сноска19,<br>который выведет таблицу графиков, соответствующих каждому из уровней<br>фактора. Другой способ сделать это, просто одновременно выведя графики<br>в одно окно, выглядит следующим образом:<br><br>&gt; xc &lt;- split(x, ind)<br><br>&gt; yc &lt;- split(y, ind)<br><br>&gt; for (i in 1:length(yc)) {<br><br>plot(xc[[i]], yc[[i]]);<br><br>abline(lsfit(xc[[i]], yc[[i]]))<br><br>}<br><br>(Примечание: функция split(), которая выводит список векторов, полученных<br>путем разделения большего вектора в соответствии с разбиением заданным<br>фактором. Это полезная функция, в основном используемая в связке с<br>boxplots. Подробнее см. на странице помощи.)<br><br>Предупреждение: цикл for() используются в R кода значительно реже,<br>чем в компилируемых языках. Код, который оперирует объектом "как целым"<br>одновременно и более прозрачный и более быстрый в R.<br><br>К другим возможностям циклов относятся конструкции<br><br>&gt; repeat expr<br><br>и<br><br>&gt; while (condition) expr<br><br>Оператор break может быть использован для прекращения любого<br>цикла, возможно досрочно. Это единственный способ прекратить цикл<br>repeat. Оператор next может быть использован для прекращения одного<br>конкретного цикла, и перехода к "следующему". Управляющая конструкция<br>чаще всего используется в соединении с функциями, которые обсуждаются в<br>"Написание ваших собственных функций", тогда и появятся другие примеры.<br><br>10 Написание вашей собственной функции<br><br>Как мы уже видели по ходу обсуждения, R язык позволяет пользователю<br>создавать объекты типа функция. Это настоящие R функции, которые<br>сохраняются в специальной внутренней форме и могут быть использованы в<br>дальнейших выражениях и т.п.. При этом язык приобретает огромную мощность,<br>удобство и элегантность, а учиться писать полезные функции является<br>одним из основных путей сделать использование R удобным и продуктивным.<br><br>Следует подчеркнуть, что большинство функций поставляющихся как часть R<br>системы, например mean(), var(), postscript() и т.п., сами написаны на R<br>и, следовательно, не существенно отличаются от написанных пользователем<br>функций.<br><br>А функция определяется присвоением вида<br><br>&gt; name &lt;- function(arg_1, arg_2, ...) expression<br><br>expression является R выражением, (обычно группированным выражением),<br>которое использует аргументы, arg_i, для вычисления значения. Значение<br>этого выражения, это то значение, которое возвращается функцией.<br><br>Вызов функции обычно принимает форму name(expr_1, expr_2, ...) и может<br>происходить в любом месте где допускается вызов функции.<br><br>10.1 Простые примеры<br><br>В качестве первого примера рассмотрим функцию для расчета двух выборочной<br>t-статистики, показав "все шаги". Это разумеется искусственный пример,<br>поскольку есть и другие, более простые способы, достижения той же цели.<br><br>Эта функция определяется следующим образом:<br><br>&gt; twosam &lt;- function(y1, y2) {<br><br>n1 &lt;- length(y1); n2 &lt;- length(y2)<br><br>yb1 &lt;- mean(y1); yb2 &lt;- mean(y2)<br><br>s1 &lt;- var(y1); s2 &lt;- var(y2)<br><br>s &lt;- ((n1-1)*s1 + (n2-1)*s2)/(n1+n2-2)<br><br>tst &lt;- (yb1 - yb2)/sqrt(s*(1/n1 + 1/n2))<br><br>tst<br><br>}<br><br>Определив эту функцию, можно выполнять двух выборочный t-тест с используя<br>следующий вызов<br><br>&gt; tstat &lt;- twosam(data$male, data$female); tstat<br><br>В качестве второго примера рассмотрим функции для прямой эмуляции команды<br>Matlab "обратный слешь", которая возвращает коэффициенты ортогональной<br>проекции вектора y на колоночное пространство матрицы X. (Это делают<br>для оценки методом наименьших квадратов коэффициентов регрессии.) Это<br>обычно делается функцией qr(), но ее иногда немного сложно использовать<br>напрямую, так что имеет смысл иметь простую функцию, как указано ниже,<br>и использовать ее без опаски.<br><br>Таким образом, если n на 1 вектор у и n на р матрицу X, тогда X\y<br>определяется как (X'X )^{-}X'y, где (X'X)^{-} является обобщенная обратной<br>величиной X'X.<br><br>&gt; bslash &lt;- function(X, y) {<br><br>X &lt;- qr(X)<br><br>qr.coef(X, y)<br><br>}<br><br>После того как этот объект был создан он может быть использован в таких<br>командах, как<br><br>&gt; regcoeff &lt;- bslash(Xmat, yvar)<br><br>и т.п.<br><br>Классическая R функция lsfit() выполнит это задание так же хорошо,<br>и детальнее ссылка20. Выше вместо этого, несколько не интуитивным<br>образом используются функции qr() и qr.coef(), что бы сделать эту часть<br>расчета. Отсюда, вероятно, если она будет использоваться часто имеется<br>определенная ценность в том, что бы иметь изолированно только эту часть<br>вычислений, в виде простой в использовании функции. Если это так, мы,<br>возможно, для еще более удобного использования пожелает сделать ее<br>матричным бинарным оператором.<br><br>10.2 Определение новых бинарных операторов<br><br>Если бы мы задали функции bslash() другое имя, а именно одну из форм<br><br>%anything%<br><br>его можно было бы использовать в выражениях в качестве бинарного<br>оператора, а не в виде функции. Предположим, например, мы выбираем ! как<br>внутренний символ. Определение функции будет начинаться как<br><br>&gt; "%!%" &lt;- function(X, y) { ... }<br><br>(Заметьте что используются кавычки.) Эта функция может быть использована<br>в виде X %!% y. (Символ "обратный слешь" сам по себе не удобный выбор,<br>так как он представляет особые проблеммы в таком контексте.)<br><br>Оператор умножения матриц, %*%, и оператор внешнего произведения %о%<br>это другие примеры определенных таким образом бинарных операторов.<br><br>10.3 Именованные аргументы и аргументы по умолчанию<br><br>Как впервые отмечается в "Генерация регулярных последовательностей",<br>если аргументы вызываемых функций, задаются в форме "name=object", то<br>они могут быть указаны в любом порядке. Кроме того, последовательность<br>аргументов может начаться не поименованной, позиционной формой, а<br>поименованные аргументы можно указать после позиционных аргументов.<br><br>Таким образом, если есть функция fun1 определена как<br><br>&gt; fun1 &lt;- function(data, data.frame, graph, limit) {<br><br>[function body omitted]<br><br>}<br><br>тогда функция может вызываться несколькими способами, к примеру<br><br>&gt; ans &lt;- fun1(d, df, TRUE, 20)<br><br>&gt; ans &lt;- fun1(d, df, graph=TRUE, limit=20)<br><br>&gt; ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df)<br><br>все являются эквивалентными.<br><br>Во многих случаях аргументам можно задать обычно принятые значения по<br>умолчанию, в этом случае они могут быть полностью опущены в вызове,<br>когда их значения по умолчанию являются подходящими. Например, если fun1<br>были определены как<br><br>&gt; fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { ... }<br><br>ее можно было бы вызвать как<br><br>&gt; ans &lt;- fun1(d, df)<br><br>что эквивалентно трем примерам выше, или как<br><br>&gt; ans &lt;- fun1(d, df, limit=10)<br><br>что изменяет одно из значений по умолчанию.<br><br>Важно отметить, что значением по умолчанию может быть выражение<br>произвольной формы, даже с участием других аргументов этой же функции:<br>они не ограничены только константами, как в нашем простом примере.<br><br>10.4 Аргумент `...'<br><br>Другая частая потребность разрешить одной функции передать набор<br>аргументов в другую. Например, многие графические функции используют<br>функцию par() и функции, такие как plot() позволяют пользователю<br>передавать графические параметры в par() для контроля графического<br>вывода. (См. "Функция par()", для более подробной информации по функции<br>par().) Это можно сделать задавая дополнительный аргумент, буквально<br>`...', у этой функции, который может затем быть передан. Макет такого<br>примера приводится ниже.<br><br>fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, ...) {<br><br>[пропущены команды]<br><br>if (graph)<br><br>par(pch="*", ...)<br><br>[еще пропущено]<br><br>}<br><br>10.5 Присвоения в функции<br><br>Заметим, что любое обычное присвоение сделаное в функции будет локальным<br>и временным и теряется после выхода из функции. Таким образом, присвоение<br>X &lt;- qr(X) не влияет на значение аргумента в вызывающей программе.<br><br>Чтобы полностью понять правила, регулирующие сферу R присвоений читателю<br>необходимо ознакомиться с понятием вычисления кадра. Это несколько<br>углубленное знание, хотя вряд ли сложное, однако тема в дальнейшем не<br>будет здесь рассматриваться.<br><br>Если требуются глобальные и постоянные назначения в рамках функций,<br>то могут быть использованы "superassignment" оператор, &lt;&lt;- или функция<br>assign(). Подробнее см. документацию. S-Plus пользователи должны понимать,<br>что &lt;&lt;- имеет отличающуюся семантику в R. Эти вопросы обсуждаются дальше в<br>"Состояние".<br><br>10.6 Более сложные примеры<br><br>10.6.1 Влияющие факторы в блочной схеме эксперимента<br><br>Как более полный, однако похожий на "закат солнца вручную", пример<br>функции, рассмотрим нахождение влияющих факторов для блочной схеме<br>эксперимента. (Некоторые аспекты этой проблемы уже обсуждались в<br>"Индексные матрицы".)<br><br>Блочная схема эксперимента определяется двумя факторами, к примеру blocks<br>(b уровней) и varieties (v уровней). Если R и K являются соответственно<br>v на v и b на b матрицами откликов и размеров блоков, и N является b на v<br>матрицей инцидентности, то влияющие факторы определяются как собственные<br>значения из матрицы E = I_v - R^{-1/2}N'K^{-1}NR^{-1/2} = I_v - A'A,<br>where A = K^{-1/2}NR^{-1/2}. Один из способов, чтобы написать такую<br>функцию, приводится ниже.<br><br>&gt; bdeff &lt;- function(blocks, varieties) {<br><br>blocks &lt;- as.factor(blocks) # minor безопасно перемещены<br><br>b &lt;- length(levels(blocks))<br><br>varieties &lt;- as.factor (varieties) # minor безопасно перемещены<br><br>v &lt;- length(levels(varieties))<br><br>K &lt;- as.vector(table(blocks)) # удаление атрибута dim<br><br>R &lt;- as.vector(table(varieties)) # удаление атрибута dim<br><br>N &lt;- table(blocks, varieties)<br><br>A &lt;- 1/sqrt(K) * N * rep(1/sqrt(R), rep(b, v))<br><br>sv &lt;- svd(A)<br><br>list(eff=1 - sv$d^2, blockcv=sv$u, varietycv=sv$v)<br><br>}<br><br>Она численно в этом случае немного лучше работает с сингулярным<br>разложением, а не процедурой нахождения собственных значений.<br><br>Результатом функции является список дающий не только влияющие факторы,<br>в качестве первого компонента, но и канонические блочные и вариационные<br>контрасты, поскольку иногда они дают дополнительную полезную качественную<br>информацию.<br><br><br>10.6.2 Сбрасывание всех имен при печати массива<br><br>Для целей печати большой матрицы или массива, часто полезно печатать<br>их форме плотного блока без всяких имен или индексов. Удаление атрибута<br>dimnames не дает такого эффекта, напротив массиву должен быть назначен<br>атрибут dimnames, состоящий из пустых строк. Например, чтобы распечатать<br>матрицу X<br><br>&gt; temp &lt;- X<br><br>&gt; dimnames(temp) &lt;- list(rep("", nrow(X)), rep("", ncol(X)))<br><br>&gt; temp; rm(temp)<br><br>Это может быть гораздо более удобно сделать с помощью функции,<br>no.dimnames(), показаной ниже, как "обертка", чтобы достичь того же<br>результата. Она также показывает, что некоторые эффективные и полезные<br>функции пользователь могут быть достаточно короткими.<br><br>no.dimnames &lt;- function(a) {<br><br>## Удалить все имена размерности из массива для компактной печати.<br><br>d &lt;- list()<br><br>l &lt;- 0<br><br>for(i in dim(a)) {<br><br>d[[l &lt;- l + 1]] &lt;- rep("", i)<br><br>}<br><br>dimnames(a) &lt;- d<br><br>a<br><br>}<br><br>Когда определена эта функция, массив может быть напечатан в плотном<br>формате используя<br><br>&gt; no.dimnames(X)<br><br>Это особенно полезно для крупных массивов целых, где представляют реальный<br>интерес патерны а не конкретные значения.<br><br>10.6.3 Рекурсивное численное интегрирование<br><br>Функции могут быть рекурсивными, и могут сами определять функции внутри<br>себя. Заметим, однако, что такие функции, или введенные переменные, не<br>наследуются вызываемые функциями в вычисляемых фреймах высшего порядка,<br>как было бы если бы они были в пути поиска.<br><br>Пример ниже показывает наивный способ выполнить одномерное численное<br>интегрирование. Интегранд оценивается в конце точек диапазона и в его<br>середине. Если в целом правило трапеции дает ответ достаточно близкий для<br>обоих частей, то последний возвращается в качестве значения. В противном<br>же процесс рекурсивно применяется к каждой части. В результате получаем<br>адаптивный процесс интеграции который концентрирует вычисление функция в<br>тех регионах, где интегранд наиболее удален от линейного. Существует,<br>однако, тяжелые накладные расходы, и функция является способной<br>конкурировать с другими алгоритмами, когда интегранд является одновременно<br>гладким и очень сложным в оценке.<br><br>Пример, который также отчасти небольшая головоломка в R программирование.<br><br>area &lt;- function(f, a, b, eps = 1.0e-06, lim = 10) {<br><br>fun1 &lt;- function(f, a, b, fa, fb, a0, eps, lim, fun) {<br><br>## функция `fun1" видна только внутри 'area'<br><br>d &lt;- (a + b)/2<br><br>h &lt;- (b - a)/4<br><br>fd &lt;- f(d)<br><br>a1 &lt;- h * (fa + fd)<br><br>a2 &lt;- h * (fd + fb)<br><br>if(abs(a0 - a1 - a2) &lt; eps || lim == 0)<br><br>return(a1 + a2)<br><br>else {<br><br>return(fun(f, a, d, fa, fd, a1, eps, lim - 1, fun) +<br><br>fun(f, d, b, fd, fb, a2, eps, lim - 1, fun))<br><br>}<br><br>}<br><br>fa &lt;- f(a)<br><br>fb &lt;- f(b)<br><br>a0 &lt;- ((fa + fb) * (b - a))/2<br><br>fun1(f, a, b, fa, fb, a0, eps, lim, fun1)<br><br>}<br><br>10.7 Область действия<br><br>Обсуждение в этом разделе несколько более техническое, чем в других<br>частях этого документа. Однако это детали одного из основных различий<br>между S-Plus и R.<br><br>Символы, которые встречаются в теле функции могут быть разделены на<br>три класса; формальные параметры, локальные переменные и свободные<br>переменные. Формальные параметры функции это те, которые входят в список<br>аргументов функции. Их значение определяется в процессе связывания<br>фактических аргументов функции с формальными аргументами. Локальные это<br>переменные, значения которых определяются вычислением выражений в теле<br>функции. Переменные, которые не являются формальными параметрами или<br>локальными переменными называются свободными переменными. Свободные<br>переменные становятся локальными переменными, если им они<br>присваиваются. Рассмотрим следующие определение функции.<br><br>f &lt;- function(x) {<br><br>y &lt;- 2*x<br><br>print(x)<br><br>print(y)<br><br>print(z)<br><br>}<br><br>В этой функции, х - формальный параметр, y является локальной переменной,<br>а z является свободной переменной.<br><br>В R связывание свободной переменной разрешаются сначала поиском в области,<br>в котором функция была создана. Это называется область действия. Сначала<br>определим функцию cube.<br><br>cube &lt;- function(n) {<br><br>sq &lt;- function() n*n<br><br>n*sq()<br><br>}<br><br>Переменная n в функции sq - это не аргумент для этой функции. Поэтому<br>она выступает свободной переменной и для определения значения, которое<br>должно быть ей назначено, должны быть использованы правила области<br>действия. Согласно статической области действия (S-Plus) значение<br>определяется глобальной переменной с названием n. В области действия (R)<br>она является параметром функции cube, поскольку это является активным<br>связыванием для переменной n в момент определения функции sq. Разница<br>между вычислением в R и вычислением в S-Plus заключается в том, что S-Plus<br>ищет глобальную переменную с названием n а R сначала ищет переменную<br>называемую n в окружении, созданном после определения cube.<br><br>## сначала вычислим в S<br><br>S&gt; cube(2)<br><br>Error in sq(): Object "n" not found<br><br>Dumped<br><br>S&gt; n &lt;- 3<br><br>S&gt; cube(2)<br><br>[1] 18<br><br>## таже функция вычисляется в R<br><br>R&gt; cube(2)<br><br>[1] 8<br><br>Области действия также могут использоваться что бы изменять состояние<br>функций. В следующем примере мы покажем, как R может быть использован<br>для имитации банковского счета. Для Функционирования банковского счета<br>необходимо иметь баланс или итог, функции для снятия, функцию для создания<br>депозитов и функции для определения текущего баланса. Это достигается<br>путем создания трех функций внутри счета, а затем возвращения списка,<br>содержащего их. Когда счет заводится он принимает численный аргумент<br>total и возвращает список, содержащий три функции. Поскольку эти функции<br>определяются в окружении, которое содержит total, они будут иметь доступ<br>к его значению.<br><br>В специальный оператора присваивания, &lt;&lt;-, используется для изменения<br>значения, связанного с total. Этот оператор смотрит назад в окружающие<br>среды в поисках такого окружения, которое содержит символ total, и когда<br>он находит такое окружение он заменяет значение, в этом окружении, со<br>значением с правой стороны. Если глобальное или верхнего уровня окружение<br>достигается и без нахождения символа total, тогда такая переменная<br>создается и значение присваивается ей. Для большинства пользователей<br>&lt;&lt;- создает глобальную переменную и присваивает значение справа на<br>лево ссылка21. Только тогда, когда &lt;&lt;- была использована в функции,<br>что была возвращена как значение другой функции происходят описываемое<br>здесь специальное поведение.<br><br>open.account &lt;- function(total) {<br><br>list(<br><br>deposit = function(amount) {<br><br>if(amount &lt;= 0)<br><br>stop("Deposits must be positive!\n")<br><br>total &lt;&lt;- total + amount<br><br>cat(amount, "deposited. Your balance is", total, "\n\n")<br><br>},<br><br>withdraw = function(amount) {<br><br>if(amount &gt; total)<br><br>stop("You don't have that much money!\n")<br><br>total &lt;&lt;- total - amount<br><br>cat(amount, "withdrawn. Your balance is", total, "\n\n")<br><br>},<br><br>balance = function() {<br><br>cat("Your balance is", total, "\n\n")<br><br>}<br><br>)<br><br>}<br><br>ross &lt;- open.account(100)<br><br>robert &lt;- open.account(200)<br><br>ross$withdraw(30)<br><br>ross$balance()<br><br>robert$balance()<br><br>ross$deposit(50)<br><br>ross$balance()<br><br>ross$withdraw(500)<br><br>10.8 Настройка окружения<br><br>Пользователи могут настраивать свои окружения несколькими<br>различными способами. Существует системный файл инициализации и<br>каждый рабочий каталог может иметь свои собственные специальные файлы<br>инициализации. Наконец могут быть использованы специальные функции .First<br>и .Last.<br><br>Место расположения системного файл инициализации берется из значения<br>переменной среды R_PROFILE. Если эта переменная не установлена<br>используется файл Rprofile.site в подкаталоге etc домашней директории<br>R. Этот файл должен содержать команды, которые Вы хотите исполнять каждый<br>раз когда запускаете R в вашей системе. Второй, индивидуальный, профайл<br>с именем .Rprofile сноска22 может быть размещен в любом каталоге. Если R<br>запускается в этом каталоге, то файл будет считан. Этот файл предоставляет<br>индивидуальным пользователям контроль над их рабочим окружением, и<br>дает в различных рабочих каталогах возможность отличающихся процедур<br>запуска. Если файла .Rprofile нет в каталоге запуска, тогда R ищет файл<br>.Rprofile в пользовательском домашнем каталоге, и использует его (если<br>он существует).<br><br>Любая функция с именем .First() в любом из этих двух профайлов или в<br>образе .RData имеет особый статус. Они автоматически выполняться в начале<br>R сессии и могут использоваться для инициализации среды. Например,<br>определение в примере ниже изменяет приглашение системы на $ и<br>устанавливает различные другие полезные вещи, которые затем могут<br>использоваться как само собой разумеющееся в остальной части сессии.<br><br>Таким образом, последовательность, в которой файлы исполняются это<br>Rprofile.site, .Rprofile, .RData а затем .First(). Определения в<br>последующих файлах маскируют определения в предыдущих файлах.<br><br>&gt; .First &lt;- function() {<br><br>options(prompt="$ ", continue="+\t") # $ как приглашение<br><br>options(digits=5, length=999) # формат чисел и область печати<br><br>x11() # графический драйвер<br><br>par(pch = "+") # рисовать символом<br><br>source(file.path(Sys.getenv("HOME"), "R", "mystuff.R"))<br><br># мои собственные функции<br><br>library(MASS) # присоединить пакет<br><br>}<br><br>Аналогично если определена функция .Last(), она (обычно) выполняется в<br>самом конце сессии. В качестве примера можно привести.<br><br>&gt; .Last &lt;- function() {<br><br>graphics.off() # небольшая мера безопасности.<br><br>cat(paste(date(),"\nAdios\n")) # Время обеда наступило?<br><br>)<br><br>10.9 Классы, общие функции и объектно-ориентированное программирование<br><br>Класс объекта определяет, как он будет обработан так называемыми общими<br>функциями. Посмотрев с другой стороны, общая функция выполняет действия<br>и обработку своих аргументов в зависимости от конкретного класса самого<br>аргумента. Если у аргумента отсутствует атрибут класса, или он имеет<br>класс не удовлетворяющий формату общей функции, всегда предусмотрено<br>действие по умолчанию.<br><br>Проясним это примером. Класс mechanism предоставляет пользователю<br>возможность проектирования и подготовки общих функций для специальных<br>целей. Среди многих других общих функций имеется plot() для вывода<br>объектов графически, summary() для подведения итогов анализов различных<br>типов, и anova() для сравнения статистических моделей.<br><br>Количество общих функций, которые могут относиться к классу в<br>специфическим способом может быть очень большим. Например, функции,<br>которые могут быть применены к некоторым распространенным объектам класса<br>"data.frame " включают<br><br>[ [[&lt;- any as.matrix<br><br>[&lt;- mean plot summary<br><br>Текущий полный список можно получить используя функцию methods():<br><br>&gt; methods(class="data.frame ")<br><br>Число классов которые общая функция может обрабатывать также может быть<br>очень большим. Например, функция plot() метод по умолчанию и варианты<br>для объектов классов "data.frame", "density", "factor", и многое<br>другое. Полный список можно получить с помощью функции methods():<br><br>&gt; methods(plot)<br><br>Для многих общих функций тело функции довольно короткое, например<br><br>&gt; coef<br><br>function (object, ...)<br><br>UseMethod("coef")<br><br>Присутствие UseMethod указывает что это общая функция. Чтобы узнать,<br>какие методы имеются мы можем использовать methods()<br><br>&gt; methods(coef)<br><br>[1] coef.aov* coef.Arima* coef.default* coef.listof*<br><br>[5] coef.nls* coef.summary.nls*<br><br>Невидимые функции обозначены звездочками<br><br>В этом примере существует шесть методов, ни один из которых нельзя<br>увидеть, введя его название. Мы сможем прочитать их введя<br><br>&gt; getAnywhere("coef.aov")<br><br>A single object matching ' coef.aov' was found<br><br>It was found in the following places<br><br>registered S3 method for coef from namespace stats<br><br>namespace:stats<br><br>with value<br><br>function (object, ...)<br><br>{<br><br>z &lt;- object$coef<br><br>z[!is.na(z)]<br><br>}<br><br>&gt; getS3method("coef", "aov")<br><br>function (object, ...)<br><br>{<br><br>z &lt;- object$coef<br><br>z[!is.na(z)]<br><br>}<br><br>Читатель может обратится к "Определение языка R" для более полного<br>обсуждения этого механизма.<br><br>11 Статистические модели в R<br><br>Этот раздел предполагает что читатель имеет некоторые познания в<br>статистической методологии, в частности, знаком с регрессионным анализом<br>и дисперсионным анализом. Позже мы сделаем несколько более амбициозных<br>предположений, а именно что что-то известно о общей линейной модели и<br>нелинейной регрессии.<br><br>Требования для подгонки статистической модели достаточно хорошо<br>определены, чтобы можно было разработать универсальный, применимый для<br>широкого спектра задач инструментарий.<br><br>R обеспечивает набор взаимосвязанных инструментов, которые делают подгонку<br>статистической модели очень простой. Как мы упоминали во введении, по<br>умолчанию отображается минимальный набор результатов, и нужно запрашивать<br>подробности результата обращаясь к функциям вывода.<br><br>11.1 Определение статистических моделей; формулы<br><br>Шаблон для статистической модели - это модель линейной регрессии с<br>независимыми, гомоскедастическими ошибками<br><br>y_i = sum_{j=0}^p beta_j x_{ij} + e_i, i = 1, ..., n,<br><br>где e_i являются NID(0, sigma^2). В матричной нотации это будет записано,<br>как<br><br>y = X beta + e<br><br>, где y является вектором отклика, X - это модель-матрица или матрица<br>плана имеющая столбцы x_0, x_1, ..., x_p, определяющих переменных. Очень<br>часто x_0 это столбец из единиц определяющий постоянное слагаемое.<br><br>Примеры<br><br>Прежде чем дать формальное определение, несколько примеров помогут<br>составить общее представление.<br><br>Предположим, у, х, x0, x1, x2, ... являются численные переменные, X -<br>это матрица и A, B, C, ... являются факторами. Ниже следующие формулы<br>задают статистические модели, справа даны описания моделей.<br><br>у ~ х<br><br>у ~ 1 + х<br><br>Обе вводят одну и ту же простую модель линейной регрессии, y по х. Первая<br>имеет неявно заданный свободный член, а вторая прямо определенный.<br><br>у ~ 0 + х<br><br>и ~ -1 + х<br><br>у ~ х - 1<br><br>Простая линейная регрессия у по х через начало координат (то есть,<br>без свободного члена).<br><br>log(y) ~ x1 + x2<br><br>Множественная регрессия трансформированной переменной, log(у), по x1 и x2<br>(со свободным членом).<br><br>y ~ poly(x,2)<br><br>y ~ 1 + x + I(x^2)<br><br>Полиномиальная регрессия у по х степени 2. Первая форма использует<br>ортогональные полиномы, а вторая использует прямо определенные члены,<br>в качестве базиса.<br><br>y ~ X + poly(x,2)<br><br>Множественная регрессия и моделью-матрицей состоящей как из матрицы X,<br>а также в терминах полинома по х степени 2.<br><br>y ~ А<br><br>Модель однофакторного дисперсионного анализа y, с классами определяемыми<br>A.<br><br>у ~ А + х<br><br>Модель однофакторного дисперсионного анализа y, с классами определяемыми<br>A, и с ковариациями х<br><br>y ~ A*B<br><br>y ~ A + B + A:B<br><br>y ~ B %in% A<br><br>y ~ A/B<br><br>Модель двух факторного не аддитивного дисперсионного анлиза y по А и<br>В. В первых двух указана одна и таже кросс-классификация, а вторые две<br>описывают одну и туже вложенную классификацию. В абстрактных терминах<br>все четыре описывают одно и тоже подмножество моделей.<br><br>y ~ (A + B + C)^2<br><br>y ~ A*B*C - A:B:C<br><br>Трех факторный эксперимент, но с моделью, содержащий только основные<br>эффекты и факторы попарного взаимодействия. Обе формулы описывают одну<br>и туже модель.<br><br>y ~ A * x<br><br>y ~ A/x<br><br>y ~ A/(1 + x) - 1<br><br>Изолированные модели простой линейной регрессии y по х внутри уровней<br>заданных в А, различными метками. В последнем виде производит четко<br>столько вычислений различных отсекаемых отрезков и коэффициентов наклона,<br>сколько имеется уровней A.<br><br>y ~ A*B + Error(C)<br><br>Эксперимент с двумя факторами воздействия, А и В, и стратифицированной<br>ошибкой определяемой фактором C. Например, разделить отображение<br>эксперимента, на участки (и следовательно подрисунки), определяемые<br>фактором C.<br><br>Оператор "~" используется для определения формулы модели в R. Форма,<br>для простой линейной модели, будет выгдядеть<br><br>response ~ op_1 term_1 op_2 term_2 op_3 term_3 .....<br><br>где<br><br>response<br><br>это вектор или матрица (или выражение вычисленное в вектор или матрицу)<br>задающие переменную(е) отклика.<br><br>op_i<br><br>является оператором, либо + или -, подразумевая включения или исключения<br>значений в модель, (первый не обязательный).<br><br>term_i<br><br>это либо<br><br>* вектор либо матричное выражение, или 1,<br><br>* фактор, или<br><br>* формула в составе факторов, векторов или матриц связаных операторами<br>формулы.<br><br>Во всех случаях каждый term определяет набор столбцов которые либо должны<br>быть добавлены, либо удалены из матрицы модели. А 1 обозначает столбец<br>свободных членов, в случае если явно не исключается по умолчанию включен<br>в матрицу модели.<br><br>Операторы формула аналогичны по действию операторам в нотации Уилкинсона<br>и Роджерса, используемых такими программами как Glim и Genstat. Одно из<br>неизбежных изменений заключается в том, что оператор "." заменяется ":"<br>поскольку точка является легальным символом имени в R.<br><br>Описание нотации приводится ниже (на основе Chambers &amp; Hastie, 1992,<br>с. 29):<br><br>Y ~ M<br><br>Y моделируется как М.<br><br>M_1 + M_2<br><br>Включить M_1 и M_2.<br><br>M_1 - M_2<br><br>Включить M_1 исключив M_2.<br><br>M_1 : M_2<br><br>Тензорное произведение M_1 и M_2. Если оба условия являются факторами,<br>то фактор "подклассов".<br><br>M_1 %in% M_2<br><br>Как M_1:M_2, но с другим синтаксисом.<br><br>M_1 * M_2<br><br>M_1 + M_2 + M_1:M_2.<br><br>M_1 / M_2<br><br>M_1 + M_2 %in% M_1.<br><br>M^n<br><br>Все условия из М вместе с "взаимодействиями" вплоть до порядка n<br><br>I(М)<br><br>Изолировать М. Внутри M все операторы имеют их обычный арифметический<br>смысл, и этот term появляется в матрицу модели.<br><br>Заметим, что в скобках, в которые обычно заключают аргументы функции<br>все операторы имеют свои нормальное арифметическое значение. Функция I()<br>является зеркальной функцией, и используется чтобы разрешить определять<br>условия в формуле модели с помощью арифметических операций.<br><br>В частности заметьте, что формула модели описывает столбцы матрицы модели,<br>определение параметров подразумевается. Это не так в других ситуациях,<br>например, при определении нелинейных моделей.<br><br>11.1.1 Контрасты<br><br>Нам необходимо по меньшей мере некоторое представление о том, каким<br>образом модель формулы описывает столбцы матрицы модели. Это легко,<br>если мы имеем непрерывные переменные, каждая из которых производит один<br>столбец в матрице модели (и свободный член задает столбец из единиц,<br>если он включен в модель).<br><br>Как насчет k-уровневого фактора А? Ответ отличается для неупорядоченного<br>и упорядоченного фактора. Для неупорядоченного факторов, k-1 столбцов<br>генерируются для показатели второго, ..., k-го уровней фактора. (Таким<br>образом, применяемая параметризация создает на каждом уровне такой<br>же контраст откликов, что и на первом.) Для упорядоченных факторов,<br>k-1 столбцы являются ортогональными полиномами по основанию 1, ..., k,<br>исключая параметры константы.<br><br>Хотя ответ уже дан, это еще не все. Во-первых, если свободный член не<br>указан в модель, которая содержит параметр фактор, первый такой параметр<br>кодируется в k столбцов дающих показатели для всех уровней. Во-вторых,<br>поведение в целом можно изменить, с помощью параметров настройки<br>контрастов. По умолчанию в R установлено<br><br>options(contrasts = c("contr.treatment", "contr.poly"))<br><br>Основная причина, по которой это упомянуто, это то что R и S имеют<br>различные значения по умолчанию для неупорядоченного факторов, S<br>использует контрасты Хелмерта. Так что, если вам нужно сравнить свои<br>результаты с учебником или статьей, где используется S-Plus, нужно<br>будет установить<br><br>options(contrasts = c("contr.helmert", "contr.poly"))<br><br>Это разница преднамеренная, так как считается, что threatment контрасты<br>(по умолчанию в R) новичкам легче интерпретировать.<br><br>Мы еще не закончили, как схемы контрастов, которые будут использоваться<br>можно установить для каждого параметра в модели с использованием функции<br>контрастов и С. Мы еще не рассмотрели взаимодействие параметров: которые<br>генерируют произведение столбцов для компонентов этих параметров.<br><br>Хотя сложные особенности и сохраняют некоторую маргинальность, формулы<br>модели в R, как правило, создают модели, которые можно было бы ожидать<br>от эксперта статистика. Подгонка, например, модели взаимодействия,<br>не включающая соответствующих главных эффектов в целом приведет к<br>неожиданным результатам, и предназначена только для экспертов.<br><br>11.2 Линейные модели<br><br>Основная функция для установки простых множественных моделей lm(),<br>а усовершенствованный вариант вызова выглядит следующим образом:<br><br>&gt; fitted.model &lt;- lm(formula, data = data.frame)<br><br>Например<br><br>&gt; fm2 &lt;- lm(y ~ x1 + x2, )<br><br>будет соответствовать множественной регрессионной модели y по x1 и x2<br>(с параметром свободного члена).<br><br>Важный (но технически необязательный) параметр data = production<br>указывает, что все параметры, необходимые для построения модели следует<br>брать в первую очередь из произведения таблицы данных. Это случай<br>независимости, подключено произведение таблицы данных в путь поиска,<br>или нет.<br><br>11.3 Общие функции для извлечения информации о модели<br><br>Результатом lm() является подогнанный объект model; технически это список<br>результатов класса "lm". Информация о подогнанной модели может быть<br>затем отображена, извлечена, визуализирована и т.п., с использованием<br>общих функций, ориентированных на объекты класса "lm". К ним относятся<br><br>add1 deviance formula predict step<br><br>alias drop1 kappa print summary<br><br>anova effects labels proj vcov<br><br>coef family plot residuals<br><br>Краткое описание наиболее часто используемых из них приводится ниже.<br><br>anova(object_1, object_2)<br><br>Сравнить субмодель с внешней моделью и вывести таблицу дисперсионного<br>анализа.<br><br>coef(object)<br><br>Вывести коэффициенты (матрицу) регрессии.<br><br>Полный синтаксис: coefficients(object).<br><br>deviance(object)<br><br>Сумма квадратов остатка, взвешенных в случае необходимости.<br><br>formula(object)<br><br>Вывести формулу модели.<br><br>plot(object)<br><br>Выводит четыре графика, показывающих остатки, подогнанные значения и<br>некоторую диагностическую информацию.<br><br>predict(object, newdata= data.frame)<br><br>Таблицы данных должны содержать переменные с теми же метками, как и<br>в оригинале. Результат - вектор или матрица предсказанных значений в<br>соответствии с подставленными значениями из data.frame.<br><br>print(object)<br><br>Печать краткого содержания объекта. Наиболее часто используются неявно.<br><br>residuals(object)<br><br>Извлечение остатков (матрицы остатков), взвешенное если необходимо.<br><br>Короткий синтаксис: resid(object).<br><br>step(object)<br><br>Выбрать подходящую модель, добавив или сбросив параметр с сохранением<br>иерархии. Возвращается модель с наименьшим значением AIC (Akaike's An<br>Information Criterion), обнаруженная в пошаговом поиске.<br><br>summary(object)<br><br>Распечатать всеобъемлющее резюме результатов регрессионного анализа.<br><br>vcov(object)<br><br>Возвращает вариационно-кавариационную матрицу основных параметров объекта<br>подогнанной модели.<br><br>11.4 Дисперсионный анализ и сравнение моделей<br><br>функции подгонки модели aov(formula, data=data.frame) действует на<br>простейшем уровне очень похоже на функцию lm(), и большинство общих<br>функций, перечисленных в таблице "Общие функции" применимы для извлечения<br>информации из модели.<br><br>Следует отметить, что в дополнение aov() позволяет анализировать модели<br>с несколькими слоями ошибок, такие, как эксперимент с расщеплёнными<br>делянками, или сбалансированного неполного блочного плана с<br>восстановлением межблочной информации. Формула модели<br><br>response ~ mean.formula + Error(strata.formula)<br><br>указывает на многослойный эксперимент с ошибками слоев определенными<br>strata.formula. В простейших случае strata.formula является просто<br>фактором, когда она определяет двухслойный эксперимент, а именно между<br>и внутри уровней фактора.<br><br>Например, со всеми переменными факторами, формула модели, такая, как<br>в выражении:<br><br>&gt; fm &lt;- aov(yield ~ v + n*p*k + Error(farms/blocks), data=farm.data)<br><br>, как правило, используется для описания эксперимента со средним модели<br>v + n*p*k и тремя слоями ошибок, а именно "между farms", "внутри farms,<br>между bloks" и "в рамках blocks".<br><br>11.4.1 Таблица ANOVA<br><br>Следует отметить, что анализ таблицы вариации (или таблиц) дан для<br>последовательности подогнанных моделей. Суммы квадратов показывают<br>уменьшение суммы квадратов остатков в результате включения конкретного<br>параметра в модель в определенное место последовательности. Поэтому только<br>для ортогональных экспериментов порядок включения будет несущественным.<br><br>Для многослойного эксперимента начинают процедуру проекцией отклика на<br>слои ошибки, по порядку, и затем подгоняют модельное среднее для каждой<br>проекции. Более подробную информацию см. Chambers &amp; Hastie (1992).<br><br>Более гибкую альтернативу полный таблице ANOVA по умолчанию, для сравнения<br>двух или более моделей можно непосредственно использовать функцию anova().<br><br>&gt; anova(fitted.model.1, fitted.model.2, ...)<br><br>На дисплее отображается ANOVA таблица различий между подогнанными<br>моделями, при подгонке по порядку. Подогнанные модели сравниваются<br>конечно, как правило, в иерархической последовательности. Это не дает<br>информацию отличную от способа по умолчанию, а просто проще для понимания<br>и контроля.<br><br>11.5 Обновление подогнанной модели<br><br>Функция update() в значительной степени функция для удобства, которая<br>позволяет подгонять модель, которая отличается от ранее подогнанной,<br>как правило, лишь несколькими дополнительно добавленными или удаленными<br>параметрами. Ее синтаксис<br><br>&gt; new.model &lt;- update(old.model, new.formula)<br><br>В new.formula специальное имя, состоящее только из точки ".", может быть<br>использовано как "соответствующая часть старой формулы модели". Например,<br><br>&gt; fm05 &lt;- lm(y ~ x1 + x2 + x3 + x4 + x5, data = production)<br><br>&gt; fm6 &lt;- update(fm05, . ~ . + x6)<br><br>&gt; smf6 &lt;- update(fm6, sqrt(.) ~ .)<br><br>будет подгонять множественной регрессии с пятью переменными взятыми<br>(предположительно) из таблицы данных production, затем подгоняются<br>дополнительные модели добавляя в регрессию шестую переменной, и затем<br>подгоняет вариант по модели, где отклик подвергнут преобразованию<br>квадратного корня.<br><br>Примечание: в особенности если задано data=аргумент в первоначальном<br>вызове функции подгонки модели, то эта информация передается с помощью<br>объекта подогнанной модели в update() и ее союзникам.<br><br>Имя "." также может использоваться в других контекстах, но с несколько<br>иным смыслом. Например<br><br>&gt; fmfull &lt;- lm(y ~ . , data = production)<br><br>будет подгонять модель с откликом у, а в качестве переменных регрессии<br>всех остальных переменных в таблице данных production.<br><br>Другие функции для изучения пошаговых последовательностей моделей add1(),<br>drop1() и step(). Названия эти дают хорошее понятие о их назначении,<br>но более подробную информацию см. в системе интерактивной помощи.<br><br>11.6 Обобщенная линейная модель<br><br>Обобщенное линейное моделирование это разработка линейных моделей для<br>учета чистым и простым способом, как не-нормальных распределений отклика,<br>так и линеаризующих преобразований. Обобщенная линейная модель может<br>быть описана в терминах следующей последовательности предположений:<br><br>* Существует отклик, y, и воздействующие переменные x_1, x_2, ...,<br>значения которых влияют на распределение отклика.<br><br>* Воздействующие переменные влияют на распределение y только через единую<br>линейную функцию. Это линейная функция называется линейным предиктором,<br>и, как правило, записывается как<br><br>eta = beta_1 x_1 + beta_2 x_2 + ... + beta_p x_p,<br><br>следовательно x_i, не влияет на распределение y, только если beta_i<br>равна нулю.<br><br>* Распределение y имеет форму<br><br>f_Y(y; mu, phi) = exp((A/phi) * (y lambda(mu) - gamma(lambda(mu))) +<br>tau(y, phi))<br><br>где phi - это параметр масштаба (возможно известный), и является<br>константой для всех наблюдений, А представляет собой предварительный<br>вес, предположительно известный, но возможно варьирующие с разными<br>наблюдениями, а $\mu$ - это среднее y. Поэтому предполагается, что<br>распределение y определяется его средней и, возможно, параметром масштаба.<br><br>* Средняя, mu, является гладкой обратимой функцией от линейного<br>предиктора:<br><br>mu = m(eta), eta = m^{-1}(mu) = ell(mu)<br><br>и эта обратная функция, ell(), называется связывающей функцией.<br><br>Эти предположения достаточно свободны, чтобы охватить широкий класс<br>моделей полезных в статистической практике, но одновременно достаточно<br>жесткие чтобы разработать по крайней мере приблизительно единую<br>методологию оценки и прогноза. Читателя можно направить к любой из работ<br>по данной тематике за более подробной информации, например, McCullagh &amp;<br>Nelder (1989) или Dobson (1990).<br><br>11.6.1 Семейства<br><br>Класс обобщенных линейных моделей обрабатывается инструментарием,<br>представленным R, в него входят gaussian, binomial, poisson, inverse<br>gaussian и gamma response распределения, а также квази-правдоподобная<br>модель, где распределение отклика прямо не задается. В последнем случае<br>дисперсионная функция должна быть определена как функция среднего,<br>но в других случаях эта функция вводится как распределение отклика.<br><br>Каждое распределение отклика допускает различные функции связи для<br>увязки среднего с линейным предиктором. То что доступно автоматически,<br>показано в следующей таблице:<br><br>Имя семейства Функция связи<br><br>binomial logit, probit, log, cloglog<br><br>gaussian identity, log, inverse<br><br>Gamma identity, inverse, log<br><br>inverse.gaussian 1/mu^2, identity, inverse, log<br><br>poisson identity, log, sqrt<br><br>quasi logit, probit, cloglog, identity, inverse, log, 1/mu^2, sqrt<br><br>Сочетание распределения отклика, функции связи и различных других<br>элементов информации, необходимое для выполнения задачи моделирования<br>называется семейство обобщенной линейной модели.<br><br>11.6.2 Функция glm()<br><br>Поскольку распределение отклика определяется воздействующими переменными<br>посредством только одной линейной функции, тот же механизм, который<br>был использован для линейных моделей может быть использован для задания<br>линейной части обобщенной модели. В семействе это задается в различными<br>способами.<br><br>Функция R для подгонки обобщенной линейной модели это glm(), который<br>используется в виде<br><br>&gt; fitted.model &lt;- glm(formula, family=family.generator, data=data.frame)<br><br>Единственным новым элементом является family.generator, который является<br>инструментом, с помощью которого описано семейство. Это имя функции,<br>создающей список функций и выражений, которые в совокупности определяют<br>и контролируют модель и процесс оценки. Хотя это может показаться на<br>первый взгляд довольно сложным, его использование очень простое.<br><br>Имена стандартных, имеющихся генераторов семейств приводятся в разделе<br>"Название семейства" в таблице в разделе "Семьи". Если есть возможность<br>выбора связи, в скобках в качестве параметра, может быть также добавлено<br>к семейству название связи. В случае квази-семейства, таким способом<br>может быть также указана дисперсионная функция.<br><br>Несколько примеров прояснит этот процесс. В gaussian семействе<br><br>Вызов такой, как<br><br>&gt; fm &lt;- glm(y ~ x1 + x2, family = gaussian, data = sales)<br><br>получит такой же результат, как<br><br>&gt; fm &lt;- lm(y ~ x1+x2, data=sales)<br><br>, но гораздо менее эффективно. Обратите внимание, поскольку gaussian<br>семейство автоматически не предоставляет выбора связи, то и не допускается<br>никаких параметров. Если задача требует gaussian семейства с нестандартной<br>связью, как правило, это может быть достигнуто, как мы увидим позже,<br>путем использования квази-семейства.<br><br>binomial семейство<br><br>Рассмотрим небольшой искусственный пример, Silvey (1970).<br><br>В Эгейском море на острове Калитос мужское население страдает от<br>врожденных заболеваний глаз, последствия которой становятся более<br>заметны с возрастом. Выборка островитян мужчин разных возрастов, была<br>протестирована на слепоту, и результаты записали. Эти данные приводятся<br>ниже:<br><br>Возраст: 20 35 45 55 70<br><br>Количество испытаний: 50 50 50 50 50<br><br>Количество слепых: 6 17 26 37 44<br><br>Проблема, по нашему мнению, заключается в том, чтобы подогнать как логит,<br>так и пробит модели этих данных, и определить для каждой модели LD50,<br>то есть возраст, в котором вероятность слепоты для мужского населения<br>составляет 50%.<br><br>Если y это число слепых в возрасте х и n число проверенных, обе модели<br>имеют вид y ~ B(n, F(beta_0 + beta_1 x)), где для пробит случая F(z)<br>= Phi(z) является стандартной нормальной функцией распределения, а в<br>логит случае (по умолчанию), F(z) = e^z/(1+e^z). В обоих случаях LD50<br>является LD50 = - beta_0/beta_1, то есть той точки, в которой аргумент<br>функции распределения равен нулю.<br><br>Первый шаг - это ввод данных, в виде таблицы данных<br><br>&gt; kalythos &lt;- data.frame(x = c(20,35,45,55,70), n = rep(50,5), y =<br>c(6,17,26,37,44))<br><br>Чтобы подогнать binomial модель с использованием glm() есть три варианта<br>ввода отклика:<br><br>* Если отклик это вектор, то предполагается что в нем двоичные данные<br>и он должен содержать только 0/1.<br><br>* Если отклик это двух-колоночная матрица предполагается, что первая<br>колонка содержит число успешных исходов, а второй содержит число неудач.<br><br>* Если отклик является фактором, его первый уровень - воспринимается как<br>"проигрыш" (0) и все другие уровни как "успех" (1).<br><br>Здесь нам нужна второе из этих соглашений, поэтому мы добавляем матрицу<br>к нашей таблице данных:<br><br>&gt; kalythos$Ymat &lt;- cbind(kalythos$y, kalythos$n - kalythos$y)<br><br>Чтобы подогнать модели мы используем<br><br>&gt; fmp &lt;- glm(Ymat ~ x, family = binomial(link=probit), data = kalythos)<br><br>&gt; fml &lt;- glm(Ymat ~ x, family = binomial, data = kalythos)<br><br>Поскольку logit связь стоит по умолчанию, этот параметр может быть<br>пропущен во втором вызове. Чтобы увидеть результаты каждой подгонки мы<br>могли бы использовать<br><br>&gt; summary(fmp)<br><br>&gt; summary(fml)<br><br>Обе модели соответствуют хорошо (даже слишком). Чтобы найти LD50 оценки<br>мы можем использовать простую функцию:<br><br>&gt; ld50 &lt;- function(b) -b[1]/b[2]<br><br>&gt; ldp &lt;- ld50(coef(fmp)); ldl &lt;- ld50(coef(fml)); c(ldp, ldl)<br><br>Фактическая оценка по этим данным дает 43,663 лет и 43,601 лет<br>соответсвенно.<br><br>Пуассон модели<br><br>У пуассона семейством по умолчанию связь логарифмическая, и на практике<br>основным использованием этой семьи является подгонка суррогатной<br>пуассоновской логлинейной модели к данным распределения, фактические<br>распределение часто многомодовое. Этот большой и важный вопрос далее<br>мы не будем обсуждать здесь. Он составляет основную сферу использования<br>негаусовых обобщенных моделей в целом.<br><br>Иногда действительно подчиняющиеся распределению пуассона данные<br>возникают на практике и в прошлом они часто анализировались как<br>нормально распределенные данные после логарифмической трансформация или<br>трансформация извлечением квадратного корня. Как изящная альтернатива<br>последнему, как в следующем примере, может подгонятся Пуассонова<br>обобщенная линейная модель:<br><br>&gt; fmod &lt;- glm(y ~ A + B + x, family = poisson(link=sqrt), data =<br>worm.counts)<br><br>Квази-максимумправдоподобные модели<br><br>Для всех семейств дисперсия отклика будет зависеть от средней и будет<br>иметь параметр масштаба в качестве множителя. Форма зависимость дисперсии<br>от средней является характеристикой распределения отклика, например для<br>распределения Пуассона Var(у) = mu.<br><br>Для квази-максимумправдоподобной оценки и вывода точное распределения<br>отклика не задается, а дается только функция связи и формула как зависит<br>от средней функция дисперсии. Поскольку квази-максимумправдоподобная<br>оценка использует формально идентичные методы как и для нормального<br>распределения, в этом семействе предусматривается возможность подгонки<br>нормальных моделей с нестандартными функциями связи или дисперсионными<br>функциями.<br><br>Например, подгонку нелинейной регрессии y = theta_1 z_1 / (z_2 - theta_2)<br>+ e, которая может быть записана альтернативно как y = 1 / (beta_1 x_1<br>+ beta_2 x_2) + e, где x_1 = z_2/z_1, x_2 = -1/z_1, beta_1 = 1/theta_1<br>и beta_2 = theta_2/theta_1. Предположим что подходящая таблица данных<br>будет создана, мы могли бы подогнать эту нелинейную регрессию, как<br><br>&gt; nlfit &lt;- glm(y ~ x1 + x2 - 1, family = quasi(link=inverse,<br>variance=constant), data = biochem)<br><br>Читатель может обратится к руководству и встроенной документации помощи<br>за дополнительной информацией, если это необходимо.<br><br>11.7 Нелинейные модели, методы наименьших квадратов и максимума<br>правдоподобия<br><br>Некоторые формы нелинейных моделей могут быть подогнаны в Обобщенной<br>Линейной Моделью (glm()). Но в большинстве случаев мы производим подгонку<br>нелинейной кривой одним из методов нелинейной оптимизации. Процедуры R в<br>нелинейной оптимизации это optim(), nlm() и (начиная с R 2.2.0) nlminb(),<br>которые обеспечивают (и превосходят) функциональность S-Plus-вых - ms()<br>и nlminb(). Мы подгоняем значения параметров, которые позволяют свести<br>к минимуму некоторые индекс отклонения-от-цели, и делаем это, пробуя<br>пошагово различные параметры. В отличие например от линейной регрессии,<br>нет никаких гарантий, что процедура сойдется к удовлетворяющей оценке. Все<br>методы требуют первоначальные предположения о значениях параметров<br>подгонки, и сходимость может зависеть критически от качества выбора<br>исходных значений параметров.<br><br>11.7.1 Метод наименьших квадратов<br><br>Один из способов, чтобы подогнать нелинейную модель заключается в<br>минимизации суммы квадратов ошибок (SSE) или остатков. Этот метод имеет<br>смысл, если ошибки наблюдения могли бы предположительно происходить из<br>нормального распределения.<br><br>Вот пример из Bates &amp; Watts (1988), стр. 51. Данные:<br><br>&gt; x &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56,<br>1.10, 1.10)<br><br>&gt; y &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)<br><br>Моделью для подгонки является:<br><br>&gt; fn &lt;- function(p) sum((y - (p[1] * x)/(p[2] + x))^2)<br><br>Для того чтобы начать подгонку мы должны задать первоначальные оценки<br>параметров. Один из способов найти разумные стартовые значения является<br>вывести график данных, оценить некоторые параметры, и наложить график<br>модели, используя эти значения.<br><br>&gt; plot(x, y)<br><br>&gt; xfit &lt;- seq(.02, 1.1, .05)<br><br>&gt; yfit &lt;- 200 * xfit/(0.1 + xfit)<br><br>&gt; lines(spline(xfit, yfit))<br><br>Мы могли бы выбрать удачнее, но начальные значения 200 и 0,1 выглядят<br>подходящими. Теперь сделем подгонку:<br><br>&gt; out &lt;- nlm(fn, p = c(200, 0.1), hessian = TRUE)<br><br>После подгонки, out$minimum это SSE, а out$estimate является оценкой<br>параметров методом наименьших квадратов. Чтобы получить оценку стандартных<br>ошибок (SE) по результату подгонки, мы делаем:<br><br>&gt; sqrt(diag(2*out$minimum/(length(y) - 2) * solve(out$hessian)))<br><br>2 в строке выше, это количество параметров. А 95% доверительный интервал<br>будет оценен параметром +/- 1,96 SE. Мы можем наложить подгонку методом<br>наименьших квадратов на следующем графике:<br><br>&gt; plot(x, y)<br><br>&gt; xfit &lt;- seq(.02, 1.1, .05)<br><br>&gt; yfit &lt;- 212.68384222 * xfit/(0.06412146 + xfit)<br><br>&gt; lines(spline(xfit, yfit))<br><br>Стандартный пакет stats предоставляет гораздо более широкие возможности<br>для подгонки нелинейных моделей методом наименьших квадратов. Эта модель<br>которую мы только что подогнали является моделью Michaelis-Menten,<br>поэтому мы можем использовать<br><br>&gt; df &lt;- data.frame(x=x, y=y)<br><br>&gt; fit &lt;- nls(y ~ SSmicmen(x, Vm, K), df)<br><br>&gt; fit<br><br>Nonlinear regression model<br><br>model: y ~ SSmicmen(x, Vm, K)<br><br>data: df<br><br>Vm K<br><br>212.68370711 0.06412123<br><br>residual sum-of-squares: 1195.449<br><br>&gt; summary(fit)<br><br>Formula: y ~ SSmicmen(x, Vm, K)<br><br>Parameters:<br><br>Estimate Std. Error t value Pr(&gt;|t|)<br><br>Vm 2.127e+02 6.947e+00 30.615 3.24e-11<br><br>K 6.412e-02 8.281e-03 7.743 1.57e-05<br><br>Residual standard error: 10.93 on 10 degrees of freedom<br><br>Correlation of Parameter Estimates:<br><br>Vm<br><br>K 0.7651<br><br>11.7.2 Метод максимального правдоподобия<br><br>Максимальное правдоподобие - это метод подгонки нелинейной модели<br>который применяется даже если ошибки не являются нормальными. Этот<br>метод находит значения параметров, которые максимизируют логарифмическую<br>функцию правдоподобия, или что эквивалентно минимизируют отрицательную<br>логарифмическую функцию правдоподобия. Вот пример из Dobson (1990),<br>стр. 108-111. Этот пример подгоняет логистическую модель доза-реакция<br>данных, в которые четко можно подогнать с помощью glm(). Данные:<br><br>&gt; x &lt;- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113, 1.8369, 1.8610, 1.8839)<br><br>&gt; y &lt;- c( 6, 13, 18, 28, 52, 53, 61, 60)<br><br>&gt; n &lt;- c(59, 60, 62, 56, 63, 59, 62, 60)<br><br>Отрицательная логарифмическая функция правдоподобия для минимизации это:<br><br>&gt; fn &lt;- function(p) sum( - (y*(p[1]+p[2]*x) - n*log(1+exp(p[1]+p[2]*x))<br>+ log(choose(n, y)) ))<br><br>Мы выбираем разумное стартовое значение и делаем подгонку:<br><br>&gt; out &lt;- nlm(fn, p = c(-50,20), hessian = TRUE)<br><br>После подгонки, out$minimum это отрицательная логарифмическая функция<br>правдоподобия, а out$estimate является оценкой параметров методом<br>максимального правдоподобия. Чтобы получить оценку SE по произведенной<br>подгонке, мы делаем:<br><br>&gt; sqrt(diag(solve(out$hessian)))<br><br>А 95% доверительный интервал будет оценкой параметра +/- 1,96 SE.<br><br>11.8 Некоторые нестандартные модели<br><br>Мы завершаем эту главу, только кратко упомянув о некоторых других<br>возможностях в R для специальных случаев регрессии и задач анализа данных.<br><br>* Смешанные модели. Рекомендованный nlme пакет предоставляет функции<br>lme() и nlme() для линейных и нелинейных моделей со смешанными эффектами,<br>которые является линейными и нелинейными регрессиями, в которых некоторые<br>коэффициенты соответствуют случайным эффектам. Эти функции интенсивно<br>используют формулы для описания моделей.<br><br>* Локально подогнанная регрессия. Функция loess() подгоняет<br>непараметрическую регрессию с помощью локальной взвешенной<br>регрессии. Такие регрессии являются полезными для проявления тенденции<br>неочевидных данных или для редукции данных для обзора большого набора<br>данных.<br><br>Функция loess входит в стандартный пакет stats, включая код для прогноза<br>следящей регрессии.<br><br>* Робастная регрессия. Есть несколько функций для подгонки регрессионных<br>моделей устойчивым образом к воздействиям экстремальных выбросов<br>в данных. Функция lqs в рекомендованном пакете MASS обеспечивает<br>современные алгоритмы для подгонки с высокой устойчивостью. Имеются в<br>пакетах менее устойчивые, но статистически более эффективные методы,<br>например, функция rlm в пакете MASS.<br><br>* Аддитивные модели. Этот метод направлен на строительство регрессионной<br>функции из гладких аддитивных функций независимых переменных, как правило,<br>по одной для каждой независимой переменной. Функции avas и ace в пакете<br>acepack и функции bruto и mars в пакете mda предусматривает несколько<br>примеров этой методики в созданных пользователями пакетах R. Расширением<br>является Обобщенная аддитивная модель, которая реализована в созданных<br>пользователями пакетах gam и mgcv.<br><br>* Древовидные модели. Вместо того чтобы добиваться четкой<br>глобализированной линейной модели для прогноза или интерпретации,<br>древовидные модели стремятся рекурсивно разбить данные, в критических<br>точках независимых переменных для раздела данных в конечном счете на<br>группы, которые максимально возможно однородны внутри группы, и как<br>можно разнородные между группами. Результаты часто приводят к пониманию,<br>которое другие методы анализа данных, как правило, не предоставляют.<br><br>Модели все еще задают в обычном формате линейной модели. Модель<br>подгоняется функцией tree(), однако много разных общих функций, таких<br>как plot() и text(), хорошо адаптированы для отображения результатов<br>подгонки древовидных моделей в графическом виде.<br><br>Древовидные модели доступны в R через сделанные пользователями пакеты<br>rpart и tree.<br><br>12 Графические функции<br><br>Графические средства являются важным и экстремально приспособляемой<br>частью среды R. Можно использовать эти возможности для показа широкого<br>спектра статистических графиков, а также что бы создать совершенно новые<br>виды графиков.<br><br>Графические возможности могут быть использованы в интерактивном и пакетном<br>режимах, но в большинстве случаев, интерактивное использование более<br>продуктивно. Интерактивное использование также просто в использовании,<br>поскольку в момент запуска R инициирует драйвер графического устройства,<br>который открывает специальное окно для отображения интерактивной<br>графики. Хотя это делается автоматически, полезно знать, что в UNIX<br>используется команда X11() и команда windows() в Windows.<br><br>Как только драйвер устройства запущен, рисующие команды R могут быть<br>использованы для производства различных графических отображений и для<br>создания совершенно новых типов изображений.<br><br>Команды рисования делятся на три основные группы:<br><br>* Высокого уровня функции рисования создают новый рисунок на графическом<br>устройстве, возможно вместе с осями, метками, названия и так далее.<br><br>* Низкого уровня функции рисования добавляют дополнительную информацию<br>к существующим рисункам, такую как дополнительные точки, линии и метки.<br><br>* Интерактивные графические функции позволяют интерактивно добавить,<br>либо получить информацию о существующем рисунке, используя графический<br>манипулятор, такой как например мышь.<br><br>Кроме того, R ведет список графических параметров, которыми можно<br>манипулировать, чтобы изменить свой рисунок.<br><br>Данное руководство описывает только, то что известно как "базовая"<br>графика. Отдельная подсистема графики из пакета grid сосуществует<br>с базовой - это более мощная, но более сложная в использовании<br>система. Существует рекомендуемый пакет lattice которая построена на<br>grid и обеспечивает способы для получения составных графиков наподобие<br>графиков из Trellis системы в S.<br><br>12.1 Высокоуровневые графические команды<br><br>Высокого уровня функции рисования призваны создать законченый рисунок по<br>данным заданным как аргументы функции. При необходимости автоматически<br>создается, оси, метки и заголовки (если не заказать иначе.) Высокого<br>уровня команды рисования всегда начинают новый рисунок, стирания текущего<br>в случае необходимости.<br><br>12.1.1 Функция plot()<br><br>Одна из наиболее часто используемых функций рисования в R - это функция<br>plot(). Это общая функция: вид производимого рисунка зависит от типа<br>или класса первого аргумента.<br><br>plot(x, y)<br><br>plot(xy)<br><br>Если х и у являются векторами, plot(х, у) выдает корреллограмму y по<br>х. Тот же эффект может быть произведен заданием одного аргумента (вторая<br>форма), либо как список, содержащий два элемента х и у, либо матрицей<br>из двух колонок.<br><br>plot(x)<br><br>Если х является временным рядов, выводится график временного ряда. Если<br>х является вектором чисел, выводится график значений вектора по индексу<br>вектора. Если х - это комплексный вектор, выводится график мнимой части<br>векторных элементов по реальным частям.<br><br>plot(f)<br><br>plot(f, y)<br><br>f является фактором, y является вектором чисел. Первый вариант создает<br>столбчатую диаграмму по f; второй вариант производит коробчатую диаграмму<br>y для каждого уровня f.<br><br>plot(df)<br><br>plot(~ expr)<br><br>plot(y ~ expr)<br><br>df это таблица данных, y - любой объект, expr это список имен объектов,<br>разделенные "+" (например, a + b + c). В первых двух вариантах выводится<br>графики распределения по переменным в таблице данных (первый вариант)<br>или по числу имен объектов (второй вариант). Третий вариант рисует y по<br>каждому объекту, указанному в expr.<br><br>12.1.2 Отображение многомерных данных<br><br>R предусматривает две весьма полезные функции, представляющие многомерные<br>данные. Если Х матрица чисел или таблица данных, команда<br><br>&gt; pairs(X)<br><br>производит матрицу попарных корреллограмм на переменных заданных<br>в столбцах Х, то есть каждый столбец Х отображается по всем другим<br>столбцам X и результирующие n(n-1) графиков расположены в виде матрицы<br>с постоянным масштабом шкал графиков по строках и столбцам этой матрицы.<br><br>Когда рассматриваются три или четыре переменных coplot может быть более<br>полезным. Если a и b вектора чисел и с вектор чисел или фактор-объект<br>(все одинаковой длинны), тогда команда<br><br>&gt; coplot(a ~ b | c)<br><br>производит ряд корреллограмм a по b для заданных значений c. Если c<br>представляет собой фактор, это просто означает, что a выводится по b на<br>каждом уровне c. Когда c численный вектор, оно делится на ряд непрерывных<br>интервалов и для каждого интервала a отображается по b для значений c из<br>данного интервала. Количество и положение интервалов можно контролировать<br>с помощью given.values=, аргумента coplot() - функция co.intervals ()<br>полезна для выбора интервалов. Вы также можете использовать два переменных<br>в команде, например<br><br>&gt; coplot(a ~ b | c + d)<br><br>, который производит корреллограмму a на b для каждого совместный<br>интервала группировки по c и d.<br><br>Функции coplot() и pairs() обе принимают аргументом panel=, который может<br>быть использован для настройки типа графика, который появится в каждой<br>из панелей. По умолчанию применяется points() для вывода корреллограммы,<br>но путем указания некоторых других низкоуровневых графических функций<br>двух векторов х и у как значения panel= можно выводить любой нужный<br>тип графиков. Примером panel функции полезной для coplots является<br>panel.smooth().<br><br>12.1.3 Графический вывод<br><br>Другие высокого уровня графические функции выводят графики различных<br>типов. Некоторые примеры:<br><br>qqnorm(x)<br><br>qqline(x)<br><br>qqplot(x, y)<br><br>Графики сравнения-распределения. Первый вариант рисует численный<br>вектор х в сравнении с ожидаемым Нормальным распределением квантилей<br>(график значений перцентилей, относящихся к долевым оценкам), а второй<br>добавляет прямую линию к такому графику, проводя ее через распределение<br>данных и квартили. Третий вариант выводит квантили х по y для сравнения<br>их распределений.<br><br>hist(x)<br><br>hist(x, nclass=n)<br><br>hist(x, breaks=b, ...)<br><br>Выводит гистограмму вектора чисел х. Как правило выбирается разумное<br>количество интервалов группировки, но можно их задать прямо аргументом<br>nclass=. Кроме того, точки разбиения можно указать точно аргументом<br>breaks=. Если задан аргумент probability=TRUE, столбцы представляют<br>вместо сумм относительные частоты. dotchart(x, ...)<br><br>Создает точечную диаграмму из данных, приведенных в х. В точечной<br>диаграмме ось у дает метки данных из х, а ось х отображает их<br>величину. Например, это позволяет легко визуально отобрать все записи<br>данных значения которых лежат в заданных диапазонах.<br><br>image(x, y, z, ...)<br><br>contour(x, y, z, ...)<br><br>persp(x, y, z, ...)<br><br>Графики трех переменных. График image рисует сетку прямоугольников,<br>используя различные цвета для отображения величины z, график contour<br>рисует горизонтали представляющие уровни z, и график persp рисует 3D<br>поверхность.<br><br>12.1.4 Параметры высокоуровневых графических функций<br><br>Есть ряд параметров, которые могут быть переданы высокоуровневым<br>графическим функциям, такие как:<br><br>add=TRUE<br><br>Принуждает функцию действовать в качестве низкоуровневой графической<br>функции, накладывая свой график на текущий (только для некоторых функций).<br><br>axes=FALSE<br><br>Подавляет вывод осей - полезно чтобы добавить собственные осей с помощью<br>функции axis(). По умолчанию, axes=TRUE, что означает отображение осей.<br><br>log="x"<br><br>log="y"<br><br>log="xy"<br><br>Приводит х, у или обе оси к логарифмическому масштабу. Это сработает<br>для многих, но не всех видов графиков.<br><br>type=<br><br>type= аргумент контролирует тип выводимого графика, а именно:<br><br><br>type="p"<br><br>Выводит отдельные точек (принято по умолчанию)<br><br>type="l"<br><br>Рисует линии<br><br>type="b"<br><br>Выводит точки, соединенные линиями (вместе)<br><br>type="o"<br><br>Рисует точки перекрытые линиями<br><br>type="h"<br><br>Рисует вертикальные линии от точек до нулевого уровня оси (график<br>high-density)<br><br>type="s"<br><br>type="S"<br><br>Графическая ступенчатая функция. В первом варианте, верх вертикали<br>определяет точу, а во втором - низ.<br><br>type="n"<br><br>Не рисовать ничего. Однако оси по-прежнему выводятся (по умолчанию) и в<br>система координат создается в соответствии с данными. Идеально подходит<br>для создания участков последовательностью низкоуровневых графических<br>функций.<br><br>xlab = строка<br><br>ylab = строка<br><br>Ось знаки х и у осей. Использование этих аргументов, чтобы изменить<br>ярлыки, как правило, названия предметов, используемых в призыв на высоком<br>уровне заговора функции.<br><br>main=строка<br><br>Название рисунка большим шрифтом, расположенное в верхней части рисунка.<br><br>sub=строка<br><br>Подзаголовок меньшим шрифтом, расположенный чуть ниже оси х.<br><br>12.2 Низкоуровневые графические команды<br><br>Иногда на высокоуровневые графические функции не дают именно такой<br>график который вы желаете. В данном случае низкоуровневые графические<br>команды могут использоваться, чтобы добавить дополнительную информацию<br>(например, точки, линию или текст) к текущему рисунку.<br><br>Некоторые из наиболее полезных низкоуровневых графических функций:<br><br>points(x, y)<br><br>lines(x, y)<br><br>Добавляет точки или связывающие линии к текущему графику. для plot()<br>аргументы типа type= также могут быть переданы в эти функции (и по<br>умолчанию "р" для points() и "l" lines().)<br><br>text(x, y, labels, ...)<br><br>Добавить текст в рисунок в точке заданных х, у. Обычно метки -<br>целочисленные или символьные вектора, в этом случае labels[i] - выводится<br>в точке (x[i], y[i]). Значение по умолчанию - 1:length(x).<br><br>Примечание: Эта функция часто используется в сочетании<br><br>&gt; plot(x, y, type="n"); text(x, y, names)<br><br>Графический параметр type="n" подавляет точки, но создает оси, а функции<br>text() поставляет специальные символы, которые заданы именами в символьном<br>векторе для каждой из точек.<br><br>abline(a, b)<br><br>abline(h=y)<br><br>abline(v=x)<br><br>abline(lm.obj)<br><br>Добавляет в текущий рисунок линию наклона b и отсекающую отрезок a. h=y<br>может быть использовано для задания y-координаты для высоты горизонтальной<br>линии проходящей через рисунок, а v=x аналогично для х-координаты задает<br>вертикальную линию. Также lm.obj может быть списком с компонентами<br>коэффициентами с length 2 (например результат функции подгонки модели),<br>которые используются в качестве отсекающего отрезка и наклона, именно<br>в таком порядке.<br><br>polygon(x, y, ...)<br><br>Ничья один многоугольник определенный заданными вершинами из (х, у),<br>и (дополнительно) затенить его штриховкой, или закрасить его, если<br>графическое устройство позволяет закраску фигур.<br><br>legend(x, y, legend, ...)<br><br>Добавляет описание к текущему графику в указанной позиции. Начертание<br>символов, стиль линий, цвета т.п., определяется метками в символьном<br>векторе описания. По меньшей мере один аргумент v (вектор той же длины,<br>как описание), с соответствующими значениями единиц измерения должен<br>быть задан, а именно:<br><br>legend( , fill=v)<br><br>Цвета для заполнения прямоугольников<br><br>legend( , col=v)<br><br>Цвета, которыми рисуются точки или линии<br><br>legend( , lty=v)<br><br>Стиль линии<br><br>legend( , lwd=v)<br><br>Ширина линии<br><br>legend( , pch=v)<br><br>Выводимые символы (символьный вектор)<br><br>title(main, sub)<br><br>Большим шрифтом добавляет заголовок main в начало текущего рисунка и<br>(дополнительно) мелким шрифтом подзаголовок sub внизу.<br><br>axis(side, ...)<br><br>Добавить оси к текущему рисунку со стороны заданной первым аргументом (от<br>1 до 4, считая по часовой стрелке снизу.) Другие аргументы контролируют<br>расположение оси внутри или рядом с рисунком, и позиции отметок и<br>меток. Полезно для добавления в дальнейшем пользовательских осей вызывать<br>plot() с аргументом axes=FALSE.<br><br>Низкоуровневые графические функции, как правило, требуют некоторой<br>позиционной информации (например, х и у координат), чтобы определить<br>место для нового элемента рисунка. Координаты приведены с точки зрения<br>пользователя координатами, которые определены в предыдущей высокоуровневой<br>графической команде и выбираются на основе предоставленной информации.<br><br>Если х и у аргументы обязательны, то достаточно задать один аргумент из<br>списка с элементами по имени x и y. Аналогично матрица с двумя столбцами<br>также подходит для ввода. Этим путем функции, такие как locator()<br>(см. ниже) могут использоваться для интерактивного определения позиции<br>на рисунке.<br><br>12.2.1 Математические формулы<br><br>В некоторых случаях бывает полезно добавить математических символов и<br>формул на график. Это может быть достигнуто в R не символьной строкой в<br>text, mtext, axis, или title, а описанием выражения. Например, следующий<br>код рисует формулу для биноминальной функции распределения:<br><br>&gt; text(x, y, expression(paste(bgroup("(", atop(n, x), ")"), p^x,<br>q^{n-x})))<br><br>Более подробную информацию, включая полный перечень доступных<br>возможностей, можно получить в R с помощью команд:<br><br>&gt; help(plotmath)<br><br>&gt; example(plotmath)<br><br>&gt; demo(plotmath)<br><br>12.2.2 Векторные шрифты Hershey<br><br>Можно задать векторные шрифты Hershey для рендеринга текста, когда<br>используются текстовые и контурные функций. Есть три причины для<br>использования шрифтов Hershey:<br><br>* Hershey шрифты могут дать результаты лучше, особенно на экране<br>компьютера, для ротированного и/или мелкого текста.<br><br>* Hershey шрифты предоставляют некоторые символы, которых нет в<br>стандартных шрифтах. В частности, имеются знаки зодиака, картографические<br>и астрономические символы.<br><br>* Hershey шрифты предоставляют кириллические и японские (Кандзи и Кана)<br>символы.<br><br>Более подробная информация, включая таблицы символов Hershey можно<br>получить в R с помощью команд:<br><br>&gt; help(Hershey)<br><br>&gt; demo(Hershey)<br><br>&gt; help(Japanese)<br><br>&gt; demo(Japanese)<br><br>12.3 Интерактивная графика<br><br>R также обеспечивает функции, которые позволяют пользователям получать<br>или добавлять информацию на график с помощью мыши. Простейшей из них<br>является функция locator():<br><br>locator(n, type)<br><br>Ожидает выбор пользователя локации на текущем рисунке, с использованием<br>левой кнопки мыши. Это продолжается до тех пор, пока не будет выбрано<br>n (по умолчанию 512) точек, или нажата другая кнопка мыши. Аргумент<br>type применим для вывода отмеченных точек и действует так же,<br>как на высокоуровневые графические команды; по умолчанию вывод<br>отсутствует. locator() возвращает координаты отдельных точек как список<br>с двумя компонентами x и y.<br><br>locator() обычно вызывают без аргументов. Это особенно полезно для<br>интерактивного выбора позиции для графических элементов, таких, как<br>описания и метки, когда трудно рассчитать заранее, куда надо пометить<br>графический элемент. Например, чтобы поставить некоторый информативный<br>текст выпадающей вблизи точки, может быть полезна команда<br><br>&gt; text(locator(1), "Outlier", adj=0)<br><br>(locator() будет проигнорировано, если текущее устройство, например<br>postscript не поддерживает интерактивного взаимодействия.)<br><br>identify(x, y, labels)<br><br>Позволяет пользователю выделить любую из точек с определенными<br>координатами х и у (используя левую кнопку мыши) путем вывода поблизости<br>соответствующего компонента labels (или индекс точки, если labels<br>отсутствует). Возвращает индексы выбранных точек, когда нажимают другую<br>кнопку мыши.<br><br>Иногда мы хотим идентифицировать избранные точки на графике, а не их<br>координаты. Например, мы можем пожелать что бы пользователь выбрал<br>некоторые интересующие наблюдения на графическом дисплее, а затем<br>обработать эти наблюдения разными способами. Задав ряд (х, у) координат<br>двумя численными векторами х и у, мы могли бы использовать функцию<br>identify() следующим образом:<br><br>&gt; plot(x, y)<br><br>&gt; identify(x, y)<br><br>Функция identify() сама не рисует, но просто позволяет пользователю<br>переместить курсор мыши и нажать левую кнопку мыши вблизи точки. Если<br>возле указателя мыши есть точка, она будет помечена своим индексом<br>(то есть, своей позицией в х/y векторах) выведенным поблизости. Можно<br>также использовать некоторые информационные строки (например, название<br>случая), в качестве выделения, используя labels аргумент для identify(),<br>или вообще отключить выделение аргументом plot = FALSE. Когда этот процесс<br>прекращается (см. выше), identify() возвращает индексы выбранных точек;<br>вы можете использовать эти индексы для извлечения отдельных точек из<br>первоначальных векторов х и y.<br><br>12.4 Использование графических параметров<br><br>При создании графики, в частности для выступлений или публикаций, R<br>по умолчанию не всегда выводит именно то, что требуется. Однако можно<br>настроить практически каждый аспект вывода с использованием графических<br>параметров. R поддерживает список из большого числа графических<br>параметров, которые контролируют среди многих других такие вещи, как<br>стиль линии, цвет, расположение рисунка и текста. Каждый графический<br>параметр имеет имя (например, 'col', который контролирует цвет) и значение<br>(например --- номер цвета)<br><br>Отдельный список графических параметров поддерживается для каждого<br>активного устройства, и каждое устройство, когда оно инициализировано,<br>по умолчанию имеет набор параметров. Графические параметры можно задать<br>двумя способами: либо перманентно, затронув все графические функции<br>связанные с текущим устройством, или временно, затрагивая только один<br>вызов графической функции.<br><br>12.4.1 Постоянные изменения параметров: функция par()<br><br>Функция par() используется для доступа к списку параметров и изменению<br>графических параметров для текущего графического устройства.<br><br>par()<br><br>Без параметров, возвращает список всех графических параметров и их<br>значения для текущего устройства. par(c("col", "lty"))<br><br>Если аргумент символьный вектор, возвращает только названные графические<br>параметры (тоже как список.) par(col=4, lty=2)<br><br>С поименованными аргументами (или одним общим списком аргументов),<br>устанавливает значения из поименованных графических параметров, и<br>возвращает первоначальные значения параметров, как список.<br><br>При настройке параметров графики функцией par() изменения значений<br>параметров постоянно, в том смысле, что все будущие вызовы графических<br>функций (от текущего устройства) будут зависеть от нового значения. Вы<br>можете думать об настройке графических параметров при этом, как о<br>настройке значений "по умолчанию" для параметров, которые будут<br>использовать все графические функции, если потом не задаются<br>альтернативные значения.<br><br>Заметим, что вызовы par() всегда влияют на значения графических<br>параметров глобально, даже когда par() вызывается внутри функции. Это<br>часто нежелательное поведение - как правило, мы хотим установить<br>некоторые параметры графики, для некоторых рисунков, а затем восстановить<br>исходные значения, чтобы не повлиять на пользовательскую сессию R. Можно<br>восстановить первоначальные ценности, сохраняя результат par(), при<br>внесении изменений и восстанавливать первоначальное значение, когда<br>рисунок завершен.<br><br>&gt; oldpar &lt;- par(col=4, lty=2)<br><br>... команды вывода ...<br><br>&gt; par(oldpar)<br><br>Чтобы сохранить и восстановить все настраиваемые [сноска23] графические<br>параметры используем<br><br>&gt; oldpar &lt;- par( no.readonly=TRUE)<br><br>... команды вывода ...<br><br>&gt; par(oldpar)<br><span style="font-family: sans-serif;"><br>12.4.2 Непостоянные изменения: параметры графических функций<br><br>Графические параметры могут быть также переданы в (почти) любые<br>графические функции как именованные аргументы. Это действует так<br>же, как передача аргументов в функции par(), за исключением того,<br>что изменения действуют только в течение срока действия вызова<br>функции. Например:<br><br>&gt; plot(x, y, pch="+")<br><br>производит коррелограмму используя знак "+", как выводимый на печать<br>символ, не изменяя символ печати по умолчанию для будущих графиков.<br><br>К сожалению, это реализовано не совсем последовательно, и при этом<br>иногда необходимо установить и сбросить параметры графики, используя<br>par().<br><br><br>12.5 Список графических параметров<br><br>В следующих разделах детализируются многие из широко используемых<br>графических параметров. В справочной документации сведения по функции<br>R par() представлены кратко, здесь дан несколько более подробный<br>вариант.<br><br>Графические параметры будут представлены в следующей форме:<br><br>имя = значение<br><br>Описание эффекта этого параметра. "Имя" это название параметра, то<br>есть имя аргумента для использования в вызове par() или графической<br>функции. "Значение" это типичное значения которое можно использовать<br>при задании параметра.<br><br>Заметим, что axes это не графические параметры, а аргументы для<br>нескольких методов plot: см. xaxt и yaxt.<br><br>12.5.1 Графические элементы<br><br>R графики состоят из точек, линий, текста и полигонов (заполненных<br>областей.) Графические параметры существуют что бы контролировать,<br>как эти графические элементы будут нарисованы, а именно:<br><br>pch="+"<br><br>Символ, который будет использоваться для рисования точек. Умолчание<br>различно для различных графических устройств, однако это, как<br>правило, круг. Выводимые точки, как правило, немного выше или ниже<br>соответствующей позиции, кроме как если вы используете "." , как<br>символ вывода, это выводит точки по центру.  pch=4<br><br>Когда pch задается как целое число между 0 и 25 включительно,<br>получается спецсимвол печати. Чтобы увидеть, какие это символы,<br>используйте команду<br><br>&gt; legend(locator(1), as.character(0:25), pch = 0:25)<br><br><br>Символы с 21 по 25 могут показаться дублирующими предыдущие символы,<br>но у них разные цвета: см. помощь по points, и приведенные примеры.<br><br>Кроме того, pch может быть символом или числом в диапазоне 32:255,<br>представляющем символ в текущем шрифте.<br><br>lty=2<br><br>Тип линии. Альтернативные стили линии не поддерживаются всеми<br>графическими устройствами (и различаются у разных устройств), но<br>тип 1 - это всегда сплошная линия, линия типа 0 всегда невидима, и<br>линии типов 2 и больше являются точечными или штриховыми, или<br>сочетаниями обоих типов.<br><br>lwd = 2<br><br>Ширина линии. Желаемая ширина линий, кратная "стандартной" толщине<br>линии. Влияет на линии осей, а также линий выводимых lines() и т.д.<br>Не все устройства поддерживают это, и многие имеют ограничения на<br>ширину, которая может быть использована.<br><br>col=2<br><br>Цвета, которые будут использоваться для точек, линий, текста,<br>заполненных областей и изображений. Номер из текущей палитры (см.<br>?palette), или название цвета.<br><br>col.axis col.lab col.main col.sub<br><br>Цвета, которые будут использоваться соответственно для аннотации<br>осей, х и у меток, заголовка и подзаголовка.<br><br>font=2<br><br>Целое которое определяет, какой шрифт использовать для текста. Если<br>возможно, устройство вывода организует это так, что 1 соответствует<br>простому тексту, 2 - выделенному, 3 курсиву, 4, выделенному курсиву<br>и 5 для символьному шрифту (включая греческие буквы).<br><br>font.axis font.lab font.main font.sub<br><br>Шрифты,которые будут использоваться соответственно для аннотации<br>осей, х и у меток, заголовка и подзаголовка.<br><br>adj=-0.1<br><br>Юстировка текста относительно позиции вывода. 0 означает юстировать<br>влево, 1 означает юстировать вправо и 0,5 центрировать горизонтально<br>относительно позиции вывода.  Фактическое значение означает долю<br>текста, которая появляется с левой стороны от позиции вывода,<br>значение -0,1 оставляет между текстом и позицией вывода пробел в<br>10% от ширины текста.<br><br>cex=1.5<br><br>Растяжение символов. Значение это желаемый размер символов текста<br>(включая выводимые символы), по отношению к размеру шрифта по<br>умолчанию.<br><br>cex.axis cex.lab cex.main cex.sub<br><br>Растяжение символов, которое соответственно будет использоваться<br>для аннотации оси, х и у меток, заголовков и подзаголовков.<br><br>12.5.2 Оси и шкалы<br><br>Многие высокоуровневые рисунки R имеют оси, также вы можете<br>самостоятельно конструировать оси низкоуровневыми графическими<br>функциями axis(). Оси имеют три основных компонента: линию оси<br>(стиль линии под контролем графического параметра lty), шкалу<br>(которая обозначает деление линии оси единицами измерения) и меток<br>шкалы (которые обозначают единицы измерения). Эти компоненты можно<br>настроить следующими параметрами графики.<br><br>lab=c(5, 7, 12)<br><br>Первые два числа это желаемое количество интервалов по х и у осям<br>соответственно. Третий номер желаемая длинна меток оси, в символах<br>(включая запятую). Выбор слишком малого значения этого параметра<br>может привести что все метки масштаба округляется до одного и того<br>же числа!<br><br>las=1<br><br>Ориентация меток оси. 0 означает всегда параллельно оси, 1 означает<br>всегда горизонтально, и 2 --- всегда перпендикулярно оси.<br><br>mgp=c(3, 1, 0)<br><br>Позиции компонентов оси. Первый компонент - это расстояние от метки<br>оси к позиции оси, в текстовых линиях. Второй компонент - это<br>расстояние до меток шкалы, и окончательный компонент - это расстояние<br>от позиции оси к линии оси (обычно ноль).  Положительные числа<br>измеряют за пределами региона рисования, отрицательные числа внутри<br>региона.<br><br>tck=0.01<br><br>Длина меток шкалы, как доля размера региона рисования. Когда tck<br>невелик (менее 0,5) метки шкалы на х и у осей вынуждены быть<br>одинакового размера. Значение 1 дает сетку линий.  Отрицательные<br>значения дают метки за пределами региона рисования.  Используйте<br>tck = 0,01 и mgp = с (1, -1.5,0) для внутренних меток шкалы.<br><br>xaxs="r" yaxs="i"<br><br>Стили для осей х и у, соответственно. Со стилями "i" (внутренний)<br>и "r" (по умолчанию) метки шкалы всегда внутри диапазона данных,<br>однако стиль "r" оставляет небольшого пространства на краях.  (S<br>имеет другие стили которые не были реализованы R).<br><br>12.5.3 Края рисунка<br><br>Одиночный рисунок в R называется фигура, и включает в себя и регион<br>рисования окруженный полями (возможно, содержащими метки осей,<br>заголовки и т.д.), и (обычно) ограничивается непосредственно осями.<br><br>Графические параметры контролирующие формат фигуры включают:<br><br>mai=c(1, 0.5, 0.5, 0)<br><br>Ширина соответственно нижнего, левого, верхнего и правого поля,<br>измеряется в дюймах.<br><br>mar=c(4, 2, 2, 1)<br><br>Аналогично mai, за исключением того, что единица измерения -- это<br>текстовые строки.<br><br>mar и mai эквивалентны в том смысле, что настройка одного вызывает<br>изменение значения другого. Часто значения по умолчанию выбраны для<br>этого параметра слишком большими; правый край требуется редко, и<br>не нужно верхнее поле если нет названия. В нижнее и левое должны<br>быть достаточными для размещения оси и меток масштаба. Кроме того,<br>размер по умолчанию будет выбран без учета размера выводимой<br>поверхности: например, используя устройство pstscript() с параметром<br>height=4 приведет к рисунку 50% которого составляют поля, если<br>используются mai или mar по умолчанию. Когда выводятся составные<br>фигуры (см. ниже) поля уменьшаются, однако это может быть недостаточно,<br>когда много фигур разделяют одну страницу.<br><br>12.5.4 Окружение составных фигур<br><br>R позволяет создать n на m массив фигур на одной странице. Каждая<br>фигура имеет свои поля, а массив фигур опционально окружен наружными<br>полями, как показано на следующем рисунке.<br><br>Графические параметры, связанные с составными фигурами это:<br><br>mfcol=c(3, 2) mfrow=c(2, 4)<br><br>Устанавливает размер массива составных фигур. Первое значение - это<br>количество строк, а второй - число столбцов.  Единственная разница<br>между этими двумя параметрами, что установление mfcol выводит фигуры<br>по колонкам; mfrow заполняет массив по строчно.<br><br>Раскладку в Рисунке можно было создать путем установки mfrow=c(3,2);<br>фигура отобразится на странице после вывода всех четырех рисунков.<br><br>Установка любого из этих показателей может сократить базовый размер<br>символов и текста (контролируется par("cex") и pointsize устройства<br>вывода). В формате с ровно двумя строками и столбцами базовой размер<br>уменьшается на коэффициент 0.83: если есть три или больше строки<br>или столбца, коэффициент уменьшения равен 0.66.<br><br>mfg=c(2, 2, 3, 2)<br><br>Позиция текущей фигуры в составном фигурном окружении. Первые два<br>номера это строка и столбец текущей фигуры; последние два числа это<br>строки и столбцы в составном массиве фигур. Используйте этот параметр<br>для перехода между фигурами в массиве. Вы даже можете использовать<br>отличающиеся от истинных значений значения для последних двух<br>аргументов, для отображения разноразмерных фигур на одной и той же<br>странице.<br><br>fig=c(4, 9, 1, 4)/10<br><br>Позиция текущей фигуры на странице. Значения параметров это позиции<br>левого, правого, верхнего и нижнего края соответственно, в процентах<br>от размера страницы, измеряемого от нижнего левого углу. Значению<br>примера соответствует фигура в нижнем правом углу страницы. Используйте<br>этот параметр для произвольного позиционирования фигур на странице.<br>Если вы хотите добавить фигуру к текущей странице, используйте<br>new=TRUE (в отличие от S).<br><br>oma=c(2, 0, 3, 0) omi=c(0, 0, 0.8, 0)<br><br>Размер внешних полей. Как mar и mai, первое измеряется в текстовых<br>строках, а второе - в дюймах, начиная с нижнего поля и делается по<br>часовой стрелке.<br><br>Внешнее поле особенно полезно для заметок на полях и т.д. Текст<br>может быть добавлен к внешнему полю функцией mtext() с аргументом<br>outer=TRUE. По умолчанию не существует внешних полей, именно поэтому<br>вы должны создать их непосредственно используя oma или omi.<br><br>Более сложные схемы срставных фигур могут быть изготовлены функциями<br>split.screen() и layout(), а также используя пакеты grid и lattice.<br><br>12.6 Устройства вывода<br><br>R может генерировать графику (разного уровня качества) почти для<br>любого типа дисплея или устройства печати. Но сначала, однако, R<br>должен быть проинформирован с каким типом устройства он будет<br>взаимодействовать. Это делается путем запуска драйвера устройства<br>вывода. Смысл драйвера устройства вывода, это преобразование<br>графических команд R ( "нарисовать линию", например) к такой форме,<br>которую конкретное устройство вывода может понять.<br><br>Драйвер устройства вывода запускают вызывая функцию драйвера<br>устройства. Существует единственная функция драйвера устройства для<br>каждого устройства графического вывода: введите help(Devices) для<br>получения полного списка. Например, ввод команды<br><br>&gt; postscript()<br><br>перенаправляет весь последующий графический вывод на принтер,<br>преобразуя его в формат PostScript. Некоторые широко используемые<br>драйвера устройств вывода:<br><br>X11()<br><br>Для использования с X11 оконной системой Unix-подобных ОС<br><br>windows()<br><br>Для использования в Windows<br><br>quartz()<br><br>Для использования в MacOS X<br><br>postscript()<br><br>Для печати на принтерах PostScript, а также создание графических<br>файлов PostScript.<br><br>pdf()<br><br>Изготавливает PDF файл, который может быть включен в другие PDF<br>файлы.<br><br>png()<br><br>Изготавливает растровый файл PNG. (Не всегда доступно: см. страницу<br>помощи).<br><br>jpeg()<br><br>Изготавливает растровый файл JPEG, лучше использовать для<br>рисунков-изображений. (Не всегда доступно: см. страницу помощи).<br><br>Когда вы закончите работать с устройством вывода, убедитесь, что<br>остановили драйвер устройства вывода путем выдачи команды<br><br>&gt; dev.off()<br><br>Это гарантирует, что устройство остановится штатно, например в<br>случае печатного устройства этой гарантирует, что каждая страница<br>завершена и отправлена на принтер. (Это происходит автоматически<br>при штатном окончании сессии.)<br><br>12.6.1 PostScript диаграммы для типографии<br><br>Добавляя параметр с именем файла в функцию драйвера вывода postscript(),<br>вы можете сохранять графику в формате PostScript в произвольный<br>файл. Рисунок будет иметь альбомную ориентацию, если только не<br>приводится параметр horizontal=FALSE, и вы можете контролировать<br>размер изображения параметрами width и height (график будет<br>масштабирован с учетом этих размеров.) Например, команда<br><br>&gt; postscript("file.ps", horizontal=FALSE, height=5, pointsize=10)<br><br>подготовит файл, содержащий PostScript код для фигуры пяти дюймов<br>высотой, возможно для последующего включения в какой либо документ.<br>Важно отметить, что если файл с именем заданным в команде уже<br>существует, он будет перезаписан. Это касается, даже если файл был<br>создан в начале той же самой R сессии.<br><br>Обычно PostScript вывод включают как рисунок в другой документ. Это<br>работает лучше всего, когда используют инкапсулированный PostScript:<br>R всегда делает совместимый графический вывод, но только в случае,<br>когда задается параметр onefile=FALSE. Происходит это из-за<br>S-совместимости: в этом случае действительно достигается то, что<br>результаты будут на одной странице (что является условием EPSF<br>спецификации). Таким образом, для получения графика для последующего<br>включения используют что-то вроде<br><br>&gt; postscript("plot1.eps", horizontal=FALSE, onefile=FALSE, height=8,<br>width=6, pointsize=10)<br><br>12.6.2 Несколько графических устройств одновременно<br><br>При профессиональном использования R зачастую бывает полезно иметь<br>несколько графических устройств вывода используемых одновременно.<br>Конечно только одно графическое устройство может принимать графические<br>команды в любой отдельный момент времени, оно обозначается как<br>текущее устройство. Когда несколько устройств открыты одновременно,<br>они образуют пронумерованную последовательность с именами определяющими<br>тип устройства вывода в каждой из позиций.<br><br>Основные команды, используемые для работы с несколькими устройствами,<br>и что они означают:<br><br>X11()<br><br>[UNIX]<br><br>windows() win.printer() win.metafile()<br><br>[Windows]<br><br>quartz()<br><br>[MacOS X]<br><br>postscript() pdf() ...<br><br><br>Каждое новый вызов функции драйвера устройства вывода открывает<br>новое графическое устройство, что расширяет на одну позицию список<br>устройств вывода. Это устройство становится текущим устройством<br>вывода, и графический вывод будет направляется на него. (Некоторые<br>платформы могут иметь дополнительные устройства).<br><br>dev.list()<br><br>Возвращает количество и наименование всех активных устройств вывода.<br>Устройство в позиции 1 списка всегда является null устройством,<br>которое вообще не принимает графических команд.<br><br>dev.next() dev.prev()<br><br>Возвращает номер и название графического устройства, последующего<br>или предыдущего соответственно.<br><br>dev.set(which=k)<br><br>Может быть использована для изменения текущего графического устройства<br>на устройство в позиции номер k списка устройств вывода. Возвращает<br>номер и метку устройства.<br><br>dev.off(k)<br><br>Закрыть графическое устройство в позиции k списка устройств вывода.<br>Для некоторых устройств, таких, как постскрипт устройства, это будет<br>либо немедленно распечатывать файл или корректно завершать файл для<br>последующей печати, в зависимости от того как было инициировано<br>устройство.<br><br>dev.copy(device, ..., which=k) dev.print(device, ..., which=k)<br><br>Делает копию устройства k. Здесь устройство - это функция драйвера<br>устройства, такое как postscript, в случае необходимости с<br>дополнительными аргументами назначенными посредством `...'.  dev.print<br>аналогично, но копируемое устройство немедленно закрывается, так<br>что завершающие, такие как печать твердой копии, действия немедленно<br>выполняться.<br><br>graphics.off()<br><br>Закрыть все графические устройства в этом списке, кроме null<br>устройства.<br><br>12.7 Динамическая графика<br><br>R не имеет встроенных возможностей для динамической или интерактивной<br>графики, например, "вращающения облака точек" или "brushing"<br>(интерактивная подсветка, (прим.перев. доступна в пакете R iplots))<br>точек. Однако обширные возможности динамической графикиимеются в<br>системе GGobi написанной Swayne, Cook и Buja доступной с адреса<br><br>http://www.ggobi.org/<br><br>ее можно будет использовать с помощью пакета R rggobi, обсуждаемого<br>в http://www.ggobi.org/rggobi.<br><br>Кроме того, пакет rgl предусматривает способы взаимодействия с 3D<br>графиками, например графиками поверхностей.<br><br>13 Пакеты<br><br>Все функции и данные R хранятся в пакетах. Лишь когда пакет загружается<br>его содержимое становится доступным. Это делается как для<br>производительности (полный список займет больше памяти и поиск будет<br>происходить дольше, чем в подмножестве), а также для помощи<br>разработчикам, которые предохранены от коллизии имен с чужим кодом.<br>Процесс разработки пакетов описан в "Создание пакетов в R". Здесь<br>мы опишем их с точки зрения пользователя.<br><br>Чтобы узнать, какие пакеты установлены в вашей инсталляции, наберите<br>команду<br><br>&gt; library()<br><br>без аргументов. Для загрузки конкретного пакета (например, пакета<br>boot, содержащего функции Davison и Hinkley (1997)), используйте<br>такую команду, как<br><br>&gt; library(boot)<br><br>Пользователи подключенные к Интернету могут использовать функции<br>install.packages() и update.packages() (через раздел меню Packages<br>в Windows и RAqua GUIs, см. "Установка пакетов") для установки и<br>обновления пакетов.<br><br>Чтобы узнать, какие пакеты уже загружены, используйте<br><br>&gt; search()<br><br>для отображения списка поиска. Некоторые пакеты могут быть загружены,<br>но не доступны в списоке поиска (см. "Пространство имен"): они будут<br>включены в список выводимый<br><br>&gt; loadedNamespaces()<br><br>Чтобы увидеть список всех доступных тем в системе помощи, касающихся<br>установленных пакетах, используйте<br><br>&gt; help.start()<br><br>что бы стартовать HTML систему помощи, и затем перейти на список<br>пакетов в разделе "Ссылки".<br><br><br>13.1 Стандартные пакеты<br><br>Стандартные (или base) пакеты объединяющая частью в исходном коде<br>R. Они содержат базовые функции, которые позволят Р работать, а<br>также наборы данных и стандартные статистические и графические<br>функции, которые описаны в данном руководстве. Они должны быть<br>автоматически доступны в любой инсталляции R. См. "Пакеты R", для<br>полного описания.<br><br>13.2 Сторонние пакеты и CRAN<br><br>Существуют сотни сторонних пакетов для R, написанных различными<br>авторами. Некоторые из этих пакетов реализуют специализированные<br>статистические методы, другие предоставляют доступ к данным или<br>оборудованию, третьи призваны дополнять руководства. Некоторые из<br>них (recommended packages) распространяются с каждой бинарной<br>дистрибуцией R. Большинство из них доступны для загрузки с CRAN<br>(http://CRAN.R-project.org/ и его зеркала), и других хранилищ,<br>таких, как Bioconductor (http://www.bioconductor.org/). В R FAQ<br>содержится список, какие пакеты существовали на момент релиза, но<br>коллекция пакетов постоянно изменяется.<br><br><br>13.3 Пространство имен<br><br>Пакеты могут иметь пространства имен, и в настоящее время все base<br>и recommended пакетов имеют пакет с набором данных. Пространство<br>имен делает три вещи: оно позволяют автору пакета скрыть функции и<br>данные, предназначенные только для внутреннего использования, это<br>предотвращает функции пакета от поломки, когда пользователь (или<br>автор другого пакета) выбирает название, которое пересекается с<br>одним из пакета, и они предусматривают способ сослаться на объект<br>в рамках конкретного пакета.<br><br>Например, t() - это функция транспонирования в R, но пользователи<br>могут определять свои собственные функции с именем t. Пространства<br>имен предохраняют переопределения пользователя от нарушения<br>старшинства, и прерывает все функции, которые пытаются транспонировать<br>матрицу.<br><br>Есть два оператора, которые работают с пространством имен. Двойное<br>двоеточие - оператор "::" выбирает определения из определенного<br>пространства имен. В примере выше, функция транспонирования всегда<br>будет доступна как base::t, поскольку оно определяется в базовом<br>пакете. Таким способом можно получить только функции, которые<br>экспортируются из пакета.<br><br>Тройное двоеточие, оператор ":::", можно увидеть в некоторых местах<br>кода R -- он действует подобно оператору двойного двоеточия, но<br>обеспечивает доступ к маскированным объектам. Пользователи чаще<br>используют функцию getAnywhere(), которая ищет сразу в нескольких<br>пакетах.<br><br>Пакеты зачастую взаимосвязаны, и загрузка одного может потребовать<br>другие, которые будут автоматически загружены. Операторы двоеточия<br>описанные выше также вызывают автоматическую загрузку соответствующего<br>пакета. Когда пакеты с имен загружаются автоматически они не<br>добавляются в список поиска.<br><br>Приложение A. Образец сеанса<br><br>Настоящий сеанс нужен, чтобы продемонстрировать вам некоторые<br>возможности R среды, через их применение. Многие функции системы<br>будут незнакомы и в начале вызовут растерянность, но эта растерянность<br>вскоре исчезнет.<br><br>Войти, запустить оконную систему.<br><br>$ R<br><br>Запустите R как принято на вашей платформе.<br><br>R программа стартует с выводом баннера.<br><br>(В R, во избежание путаницы, приглашение слева не будет показываться.)<br><br>help.start()<br><br>Стартует HTML интерфейс к системе интерактивной помощи (с помощью<br>браузера имеющегося на вашей машине). Вы должны вкратце изучить<br>возможности этой системы с помощью мыши.<br><br>Сверните окно с помощью и переходите к следующей части.<br><br>х &lt;- rnorm(50)<br><br>y &lt;- rnorm(х)<br><br>Создает два псевдослучайные нормальных векторов с х и у - координатами.<br><br>plot(х, у)<br><br>Рисует точки на плоскости. Автоматически появится окно графического<br>вывода.<br><br>ls()<br><br>Показывает R объекты, которые в настоящее время находятся в рабочем<br>пространстве R.<br><br>rm(х, у)<br><br>Удаляет не нужные объекты. (Очистка).<br><br>х &lt;- 1:20<br><br>Создает х = (1, 2, ..., 20).<br><br>w &lt;- 1 + sqrt(х)/2<br><br>"Весовой" вектор стандартных отклонений.<br><br>dummy &lt;- data.frame(x=x, y= x + rnorm(x)*w) dummy<br><br>Сделать таблицу данных из двух столбцов, х и у, и вывести его.<br><br>fm &lt;- lm(y ~ x, data=dummy) summary(fm)<br><br>Подогнать простую линейную регрессию у по х и вывести результат<br>анализа.<br><br>fm1 &lt;- lm(y ~ x, data=dummy, weight=1/w^2) summary(fm1)<br><br>Поскольку мы знаем стандартные отклонения, мы можем подогнать<br>взвешенную регрессию.<br><br>attach(dummy)<br><br>Зделать столбцы в таблице данных видимыми в качестве переменных.<br><br>lrf &lt;- lowess(x, y)<br><br>Вычислить функцию непараметрической локальной регрессии.<br><br>plot(x, y) Стандартный рисунок точек.<br><br>lines(x, lrf$y) Добавить в него локальную регрессию.<br><br>abline(0, 1, lty=3)<br><br>Истинная линия регрессии: (отсекающий отрезок 0, наклон 1).<br><br>abline(coef(fm))<br><br>Невзвешенная линия регрессии.<br><br>abline(coef(fm1), col = "red")<br><br>Взвешенная линия регрессии.<br><br>detach()<br><br>Удалить таблицу данных из пути поиска.<br><br>plot(fitted(fm), resid(fm), xlab="Fitted values", ylab="Residuals",<br>main="Residuals vs Fitted")<br><br>Стандартный диагностический график регрессии для проверки на<br>гетероскедастичность. Вы ее видите?<br><br>qqnorm(resid(fm), main="Residuals Rankit Plot") График нормальных<br>значений для проверки асимметрии, эксцесса и выпадающих значений.<br>(Не очень полезен в данном случае).<br><br>rm(fm, fm1, lrf, x, dummy) Снова очистка.<br><br>В следующем разделе будут проанализированы данные из классического<br>эксперимента Michaelson и Morley для измерения скорости света. Этот<br>набор данных доступен в объекте morley, но мы считаем ее чтобы<br>проиллюстрировать функцию read.table.<br><br>filepath &lt;- system.file("data", "morley.tab" , package="datasets")<br>filepath<br><br>Записать путь к текущему файлу данных.<br><br>file.show(filepath)<br><br>Не обязательно: посмотреть на файл.<br><br>mm &lt;- read.table(filepath) mm<br><br>Читает данные Michaelson и Morley, как таблицу данных, и выводит<br>их. Здесь пять, надлежащим образом закодированых, экспериментов<br>(столбец Expt), каждый имеет 20 прогонов (столбец Run), а sl является<br>измеренной скоростью света.<br><br>mm$Expt &lt;- factor(mm$Expt) mm$Run &lt;- factor(mm$Run)<br><br>Трансформация Expt и Run в факторы.<br><br>attach(mm)<br><br>Сделать таблицу данных видной в позиции 3 (по умолчанию).<br><br>plot(Expt, Speed, main="Speed of Light Data", xlab="Experiment No.")<br><br>Сравнить пяти экспериментов простыми коробочными диаграммами.<br><br>fm &lt;- aov(Speed ~ Run + Expt, data=mm) summary(fm)<br><br>Анализировать, как рандомизированный блок, с "runs" и "experiments"<br>в качестве факторов.<br><br>fm0 &lt;- update(fm, . ~ . - Run) anova(fm0, fm)<br><br>Подогнать к субмодель опуская "runs", и сравнить с помощью формального<br>дисперсионного анализа.<br><br>detach() rm(fm, fm0)<br><br>Почистим перед дальнейшей работой.<br><br>Мы сейчас посмотрим на некоторые дальнейшие графические возможности:<br>контурные графики и графики изображений.<br><br>x &lt;- seq(-pi, pi, len=50) y &lt;- x<br><br>х это вектор из 50 равномерно распределены значения в интервале<br>[-pi\, pi]. y такой же вектор.<br><br>f &lt;- outer(x, y, function(x, y) cos(y)/(1 + x^2))<br><br>f - это квадратная матрица, причем строки и столбцы индексированы<br>как х и у, соответственно, состоит из значений функции cos(y)/(1 +<br>x^2).<br><br>oldpar &lt;- par(no.readonly = TRUE) par(pty="s")<br><br>Сохраняем параметры графического вывода и устанавливаем "квадратный"<br>регион вывода графики.<br><br>contour(x, y, f) contour(x, y, f, nlevels=15, add=TRUE) Делаем<br>контурную карту f; добавляем побольше линий для детальности<br>изображения.<br><br>fa &lt;- (f-t(f))/2<br><br>fa - это "асимметричная часть" f. (t() это транспонирование).<br>contour(x, y, fa, nlevels=15)<br><br>Делаем контурный рисунок, ...<br><br>par(oldpar)<br><br>... и восстановливаем старые графические параметры.<br><br>image(x, y, f) image(x, y, fa)<br><br>Делаем пару высокочетких графиков-изображений, (из которых можно<br>получить если нужно распечатку)<br><br>rm (х, у, f, fa)<br><br>... и очищаем перед дальней работой.<br><br>R умеет комплексную арифметику:<br><br>th &lt;- seq(-pi, pi, len=100) z &lt;- exp(1i*th)<br><br>1i используется для комплексного числа i.<br><br>par(pty="s") plot(z, type="l")<br><br>Вывод комплексных аргументов означает график мнимой части числа по<br>реальной. Это должен быть круг.<br><br>w &lt;- rnorm(100) + rnorm(100)*1i<br><br>Предположим, нам нужны точки в пределах единичной окружности.  Один<br>из способов, это получить комплексные числа со стандартно нормально<br>распределенной реальной и мнимой частями ...<br><br>w &lt;- ifelse(Mod(w) &gt; 1, 1/w, w)<br><br>... и отобразить все выходящие за пределы круга на их обратное<br>значение.<br><br>plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+",xlab="x", ylab="y")<br><br>lines(z)<br><br>Все точки внутри единичной окружности, но распределение не является<br>равномерным.<br><br>w &lt;- sqrt(runif(100))*exp(2*pi*runif(100)*1i)<br><br>plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+", xlab="x", ylab="y")<br><br>lines(z)<br><br>Второй метод используется равномерное распределение. Точки должны<br>теперь выглядеть более равномерно распределенными по всему кругу.<br><br>rm(th, w, z)<br><br>Снова уборка.<br><br>q()<br><br>Выход из R программы. Вам будет задан вопрос, хотите ли вы сохранить<br>рабочее пространство R, и для такой учебной сессии как эта, это вам<br>наверное не понадобится.<br><br>Приложение Б Запуск R<br><br><br>Б.1 Вызов R из командной строки<br><br>При работе в UNIX или в командной строке Windows, команда "R" может<br>использоваться как для начала основной программы R в виде<br><br>R [опции] [&lt; файл ввода] [&gt; файл вывода],<br><br>или через "R CMD" интерфейс, как оболочку для различных средств R<br>(например, для обработки файлов в формате документации R или<br>управления дополнительными пакетами), которые не предназначены для<br>вызова "напрямую".<br><br>Вы должны обеспечить, чтобы или переменная среды TMPDIR не была<br>установлена, или же указывала на допустимое место создания временных<br>файлов и каталогов.<br><br>Большинство опций контролируют, что должно происходить в начале и<br>конеце R сессии. Механизм запуска выглядит следующим образом (см.<br>также встроенную систему помощи по теме `Загрузка" для получения<br>дополнительной информации, а также следующий раздел для<br>Windows-специфических деталей).<br><br>* Если не было задано --no-environ, R ищет пользовательские и<br>системные файлы для процесса настройки переменных окружения.  Название<br>системного файла указано в переменной окружения R_ENVIRON; если это<br>не задано используется $R_HOME/etc/Renviron.site (если она существует).<br>Пользовательский файл с настройками ищется как .Renviron в текущем<br>или в домашнем каталоге пользователя (именно в этом порядке). Эти<br>файлы должны содержать строки в форме "имя = значение". (См.<br>help(Startup) для подробного описания.) Переменные, которые вы,<br>возможно, захотите установить включают R_PAPERSIZE (размер бумаги<br>по умолчанию), R_PRINTCMD (команда печати по умолчанию) и R_LIBS<br>(указывается перечень каталогов R библиотек для поиска дополнительных<br>пакетов).<br><br>* Затем R ищет загрузочный системный профиль если не было опции<br>командной строки --no-site-file. Имя этого файла берется из значения<br>переменной среды R_PROFILE. Если эта переменная не установлена, по<br>умолчанию используется $R_HOME/etc/Rprofile.site, если такая<br>существует.<br><br>* Затем, если не было --no-init-file, R ищет файл с именем<br>.Rprofile в текущем каталоге, или в пользовательском домашнем<br>каталоге (в таком порядке) и читает его.<br><br>* Также загружается сохраненный образ .RData, если он есть (если<br>не было указано --no-restore или --no-restore-data).<br><br>* Наконец, если существует функция .First, то она выполняется.  Эта<br>функция (а также .Last, которая выполняется в конце сессии R) может<br>быть определена в соответствующем профиле запуска, или находится в<br>.RData.<br><br>Кроме того, существуют опции для контроля имеющейся в распоряжении<br>R процесса памяти (см. для дополнительной информации интерактивную<br>помощь по теме "Память"). Пользователи обычно не должны их использовать,<br>если только они не пытаются ограничить объем используемой R памяти.<br><br>R принимает следующие опции командной строки.<br><br>--help -h<br><br>Вывод коротких сообщений помощи в стандартный вывод и успешное<br>завершение.<br><br>--version<br><br>Вывод информации о версии в стандартный вывод и успешное завершение.<br><br>--encoding=enc Задайть кодировку для ввода с консоли или stdin. Это<br>необходимо что бы зделать кодировку известной iconv: см. его страницу<br>помощи.<br><br>RHOME<br><br>Распечатать путь к R "домашней директории" в стандартный вывод и<br>успешно выйти. Помимо front-end сценариев оболочки и man страниц,<br>R инсталятор устанавливает все (исполняемые файлы, пакеты и т.д.)<br>в этот каталог.<br><br>--save --no-save<br><br>Контролирует должны ли быть сохранены наборы данных или нет в конце<br>этой R сессии. Если ничего не задается в интерактивной сессии,<br>пользователю предлагается вариант желаемого поведения по команде<br>q() в конце сессии, в не интерактивной выбор одного из вариантов<br>должен быть указан или задан с помощью других параметров (см. ниже).<br><br>--no-environ<br><br>Не читать ни один файл пользователя для установки переменных<br>окружения.<br><br>--no-site-file<br><br>Не читайть системный профиль при запуске.<br><br>--no-init-file<br><br>Не читать профайл пользователя при запуске.<br><br>--restore<br><br>--no-restore<br><br>--no-restore-data<br><br>Контролирует должен ли быть восстановлен при запуске или нет<br>сохраненный образ (в файл .RData в каталоге, где стартует R).  По<br>умолчанию установлено восстановить. (--no-restore применяет все<br>конкретные --no-restore-* вариантов.)<br><br>--no-restore-history<br><br>Контролирует должны ли быть восстановлены при запуске или нет история<br>команд (обычно файл .Rhistory в каталоге, где запускается R, но<br>может быть установлена в переменной среды R_HISTFILE).  По умолчанию<br>будет восстановлена.<br><br>--no-Rconsole<br><br>(только Windows) Запрет загрузки Rconsole при запуске.<br><br>--vanilla<br><br>Совмещает --no-save, --no-environ, --no-site-file, --no-init-file<br>и --no-restore. Под Windows включает в себя --no-Rconsole.<br><br>-f file<br><br>--file=file<br><br>Принять ввода из file: "-" означает stdin. Применяет --no-save -<br>если --save не было явно задано.<br><br>-e expression<br><br>Используйте выражения в качестве ввода. Может быть использованы<br>одна или несколько -e опций, но не одновременно с -f или --file.<br>Применяет --no-save, если не было задано --save. (Существует предел<br>10000 байт на общую длину выражения, вводимого таким образом.)<br><br>--no-readline<br><br>(только UNIX) Отключает редактирование командной строки с помощью<br>readline. Это полезно при запуске R внутри Emacs, при использовании<br>пакета ESS ( "Emacs Speaks Statistics"). См.  "Редактор командной<br>строки", чтобы получить дополнительную информацию.<br><br>--ess<br><br>(только Windows) Установить Rterm для использования режимом<br>R-inferior-mode в ESS.<br><br>--min-vsize=N<br><br>--max-vsize=N<br><br>Задать минимальный и максимальный объем памяти для объектов переменных<br>размеров, посредством установки "vector heap" размера в N байт.<br>Здесь, N должен быть либо целое или целое дополненное на "G", "M",<br>"K", или "k", что означает "Giga" (2^30), "Mega" (2^20), компьютерное<br>"Kilo" (2^10), или обычное "kilo" (1000).<br><br>--min-nsize=N<br><br>--max-nsize=N<br><br>--max-ppsize=N<br><br>Указать количество памяти используемое для объектов фиксированного<br>размера, установив число "cons cells" в N. См.  в предыдущей опции<br>сведения о N. Cons cell занимает 28 байт на 32-битной машине и, как<br>правило, 56 байт на 64-битной машине.</span><br><br>
</body>
</html>